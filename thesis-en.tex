\documentclass[licencjacka,en]{pracamgr}
\usepackage{hyperref}

\autor{Tomasz Nowak}{429575}
\autori{Michał Staniewski}{429598}
\autorii{Mieszko Grodzicki}{429132}
\autoriii{Bartosz Smolarczyk}{429594}
\opiekun{mgr Michał Możdżonek\\
  Institute of Informatics\\
  }
\date{May 2023}
\kierunek{Computer Science}
% Wg klasyfikacji Socrates-Erasmus:
\dziedzina{
11.3 Computer Science\\
}
% Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
\klasyfikacja{
  D. Software\\
  D.2. Software Engineering\\
  D.2.4. Software/Program Verification
  }

\title{Accelerating package expansion in Rust through development of a semantic versioning tool}
\titlepl{Przyspieszenie rozwoju pakietów w języku Rust poprzez rozbudowę narzędzia do semantycznego wersjonowania}
\keywords{Rust, semantic versioning, continuous integration, package manager}

\begin{document}
\maketitle

\begin{abstract}
In many programming languages there exist countless nuances,
making developers accidentally release new versions of their packages
that are not backwards-compatible.
Such releases can directly impact projects which are using their packages,
causing bugs or even compilation errors when using the latest version.
One of the affected languages is Rust,
which also lacks (itself) a built-in mechanism for enforcing semantic versioning.

The aim of this thesis is to describe the development of a tool
for Rust programmers to reduce the chances of publishing
a new version of the code that violates semantic versioning.

There are already on-going plans to bundle this tool
into the language's standard development toolchain.
It would make it commonly used and therefore help users to safely get bug fixes,
security patches and new functionality,
without worrying about their app being broken by a dependency change.
\end{abstract}

% Abstrakt po polsku (potrzebny tylko w APD?)
% W wielu językach programowania istnieją liczne niuanse sprawiające, że deweloperzy
% omyłkowo publikują nowe wersje swoich pakietów bez zachowania kompatybilności wstecznej.
% Takie sytuacje mogą bezpośrednio wpłynąć na projekty korzystające z ich pakietów,
% powodując błędy bądź nawet uniemożliwiając kompilację po aktualizacji do najnowszej wersji.
% Jednym z języków dotkniętych tym problemem jest Rust, który nie posiada wbudowanego
% mechanizmu wymuszającego semantyczne wersjonowanie.

% Celem tej pracy jest przedstawienie rozwoju narzędzia dla języka Rust, które
% zmniejsza ryzyko publikacji kodu nieprzestrzegającego zasad semantycznego wersjonowania.

% Są również plany, aby narzędzie to stało się częścią standardowego toolchainu
% deweloperskiego. Skutkowałoby to jego powszechnym użyciem i tym samym zagwarantowałoby
% użytkownikom, że korzystanie z poprawek błędów, łatek bezpieczeństwa oraz nowych
% funkcjonalności pakietów nie doprowadzi do awarii ich aplikacji.

\tableofcontents
%\listoffigures
%\listoftables

\chapter*{Executive summary}
\addcontentsline{toc}{chapter}{Executive summary}

TODO:
\begin{itemize}
	\item write the executive summary (around one page long)
	\item describe in short what is the goal of the project and what it solves
	\item describe that the project is indeed needed
	\item mention what we've done and how it moved the project towards the vision
	\item mention the results and the impact on the community
\end{itemize}

\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

Rust is a relatively new language that has lately been gaining on popularity.
Amongst its standard development toolchain there is a software called cargo
-- Rust's build system and package manager,
which handles building a crate -- a package with Rust code.
One of cargo's responsibilities is to search for the newest crate versions,
download them and build dependencies
(that is, other libraries / crates that the code uses).

Cargo assumes that all crates follow semantic versioning
-- a set of rules that decide when it is safe to use the new version of a library
without any problems (the projects that depend on this library must still compile).
Thanks to that, developers of libraries can release patches and bugfixes
and cargo by default will automatically use those newest releases.
The exact definition of semantic versioning is explained in chapter \ref{r:chapter_definitions}.

It turns out that it is not obvious which changes are backwards-compatible
and which are not. There are numerous examples (listed in \ref{r:section_usageofsemver})
where experienced Rust developers made a mistake
(due to insufficient knowledge about the language or by overlooking something)
that changed the public API (Application Programming Interface) of a library in such a way that
users' code stopped compiling.

The authors of this thesis present their work on a tool that detects and notifies about
a subset of problems that make Rust libraries' public API non-backwards compatible,
with the goal to make problems with semantic versioning less frequent in the Rust community.
The exact goals of this project are described in chapter \ref{r:chapter_vision}.

The project is open-source -- all of the authors' work is visible in public repositories
(listed in \ref{r:section_projectstructure}). The project existed before their contributions,
thus chapter \ref{r:chapter_implementation} mainly describes how they have
extended the project's functionalities and fixed its issues.
Chapter \ref{r:chapter_evaluation} is a summary of their results and the project's impact
on the Rust community.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             Definitions             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Definitions}\label{r:chapter_definitions}

\section{Rust language}

With its first stable release in 2015, Rust is a relatively new programming language that
puts a strong emphasis on type-safety, memory-safety, performance and concurrency. Unlike
other memory-safe languages, Rust does not use reference counting nor a garbage collector.
Instead it tracks the object lifetime of all the program's references during compilation,
using its built-in mechanism named ``borrow checker''.

Among many benefits and advantages of using Rust, there are three dominant features. Firstly,
it provides the user with a great performance, both time- and memory-wise, allowing for
writing efficient applications. Secondly, it is reliable -- with extensive type system and
focus on runtime safety, Rust prevents the user from making multiple bugs
already during compilation. Finally, it boosts productivity -- its documentation is
comprehensive and the compiler's error messages are clear and helpful. Rust also provides
an easy to use, integrated package manager and a dedicated build tool (named cargo),
an auto-formatter and many more.

According to surveys \cite{survey} conducted amongst developers, Rust is considered to be the most
enjoyable programming language for the 7th year in a row (as of 2022 summary, meaning it was always
on top since its release in 2015). Over 87\% of respondents who have previously used Rust would
like to continue programming in it.

Because of the high level of safety it provides, Rust has also become the secondary
language for writing the Linux kernel (with the primary being C). While there have been
attempts to add other languages (f.e. C++ in 1997), Rust is the first one to successfully
make it since the kernel's first release in 1991.

\section{Rust's package manager and build system -- cargo}

Cargo is the official package manager for Rust. It is responsible for compiling the user's
packages, downloading their dependencies and uploading them to the selected package registry.
It is important to note that in Rust, packages are often refered to as \texttt{crates} with both
names being equivalent and commonly used. Most of the currently publicly available crates are
stored in the Rust community's default crate registry, \texttt{crates.io}. The role of the
registries is to allow users to easily find appropriate crates for their projects, as well as
publish their own work to be used by others. Each registry contains an index, which itself has
a searchable list of all the crates available within its registry. Cargo uses the selected registry
and index to download crates and update dependencies.

One can think of cargo as the Rust analogue of Python's pip. But despite their similar roles,
cargo has many advantages making it a lot safer than pip:
\begin{itemize}
	\item Cargo's crates are always installed using virtual environments, thus they cannot be
		installed in a location that would interfere with unrelated code.
	\item When a user adds a crate to their project, they can only use its direct, public interface.
		There is no possibility to access the interfaces of the dependencies that the added crate
		is using itself.
	\item The dependency's name must also be included in a special file named \texttt{Cargo.toml},
		not just in the source code file.
	\item To make the package's public interface explicit, Rust provides a series of tools for
		privacy management. Because of this, it is much more difficult for the user to make their
		project depend on something that the package's author did not intend to offer and could
		make private in future versions, causing a difficult to detect break on the user's end.
	\item Compatibility is taken seriously in Rust, thus packages' APIs (Applications Programming
		Interfaces) are expected to be backwards-compatible (and to follow semantic versioning,
		described in section \ref{r:section_semver}) when a new version is released. When a package
		does not satisfy this requirement, there exists a procedure called \textit{yanking}.
		It allows to remove the faulty version from the index without deleting any data, but moves
		the index back to the most recent working version. Yet in case an incompatible package is
		downloaded before being yanked, projects using the package still mostly break during
		compilation or build time rather than runtime.
	\item The packages are also written in Rust and never require anything to work other than the
		package code itself. This minimizes the threat of missing pre-installed
		system dependencies.
	\item Cargo allows for an executable to contain different versions of the same package,
		enabling the user to include multiple dependencies based on a shared sub-dependency.
		When multiple versions of the sub-dependency are required, they are all included
		without conflicts.
\end{itemize}

Each package in Rust contains a special \texttt{Cargo.toml} file, called \textit{manifest}. It is
written in the TOML format for simplicity and contains all the metadata necessary for the package
to compile. Every manifest has numerous sections, with the most important two being:
\begin{itemize}
	\item \texttt{[package]} -- contains the information for cargo to compile the package.
		The minimum that must be provided are the package's name and version. Additional fields
		may be required when the maintainer wants to share their work with others by publishing
		to a registry.
	\item \texttt{[dependencies]} -- lists all of the package's dependencies. Before compiling,
		cargo has to search for and download all of them. The default search location is crates.io.
\end{itemize}
Presence of the manifest file allows the crates.io registry to display useful information about
a particular package. The users are provided with a \texttt{README.md} file, instructions on how
to add the package to their own Cargo.toml file, a list of all available versions, statistics
regarding the downloads for each version and more.

There also exists a second file for cargo -- \texttt{Cargo.lock}. It contains detailed
information about the used dependencies. Since all dependencies come from some version control
system, the user may not need to provide an exact revision of a dependency in their
\texttt{Cargo.toml} file. In this case, there are two scenarios for what happens with the
\texttt{Cargo.lock} file during compilation:
\begin{itemize}
	\item \texttt{Cargo.lock} is \textit{not} present -- cargo then creates it and for each
		dependency in the manifest downloads the most recent revision available, saving additional
		data about it in the file.
	\item \texttt{Cargo.lock} is present -- for the dependencies already present in the file, cargo
		does not look for their newest version and instead downloads the one specified in the file.
		For dependencies that are not present, it does the same as above except it adds them to
		the file rather than overwrites it.
\end{itemize}
There is a dedicated command for updating the dependencies -- \texttt{cargo update}.
Upon execution, the \texttt{Cargo.lock} file is either created or updated with the latest
revisions of used dependencies.

Besides downloading dependencies, users can also publish their own packages using
the \texttt{cargo publish} command. To use the command, the user must first authenticate with
an API token. After doing so, the command first performs preliminary checks, including searching
the manifest for a key to determine whether the user is allowed to upload their package
to the selected registry (by default crates.io). Once the checks are passed, the package is
uploaded and available publicly.

\section{Semantic versioning (semver)}\label{r:section_semver}

Semantic versioning is a set of rules and requirements dictating how version numbers for packages
are assigned and incremented. They are based on, but not limited to currently widely used
practices in both open-source and closed software development. For these rules to work, one has to
first declare a clear and precise public API, changes of which refer to specific incrementations of
the package version number. The number is most often denoted as X.Y.Z (Major.Minor.Patch), where:
\begin{itemize}
	\item \textbf{Major} number is incremented when backwards-incompatible API changes were made,
	\item \textbf{Minor} number is incremented when a functionality was added in
		a backwards-compatible manner,
	\item \textbf{Patch} number is incremented when backwards-compatible bugfixes were made.
\end{itemize}
With these rules, version numbers and their changes reflect actions in the underlying
package's code. By definition, two versions are considered compatible if their leftmost non-zero
component remains unchanged.

The main purpose of semantic versioning is to track the changes of a package's API and reflect
their severity with appropriate numbering.
When systems with multiple dependencies are considered, the lack of semver can have serious
consequences. If the dependency rules are too tight, one is in danger of facing a version lock
(inability to release a new version of one package without new versions of all packages depending
on it). On the other hand, if the rules are too loose, there is a risk of version promiscuity
(assuring that currently released version will be compatible with too many future releases).
Without semver, such issues can occur and make it difficult for developers to further expand
their projects.

In Rust, semver is used by cargo for specifying package version numbers. This makes for a common
compatibility convention between different versions of the same package. Cargo assumes that
it is safe to update a dependency within a compatibility range without it breaking the build.
This range can be defined in the manifest using the \textit{version requirement syntax}, allowing
the user to select the upper bound for maximum compatible number anywhere from one, specific
version (not allowing any updates), to no limit at all (equivalent to allowing even major updates).
The default behaviour is to update until the next major version.

% When updating, if multiple packages share a dependency, cargo's resolver attempts to ensure
% that they use as few versions of it as possible (ideally all packages may share a dependency
% version), while ensuring none of them is forced to use a version outside of their compatibility
% range. At the same time, the resolver tries to use the greatest version currently available within
% that range. However, the resolver does not allow to use multiple versions of a package within the
% same compatibility range and returns an error. For example, it is not possible to use two versions
% of a package with the same Major and different Minor numbers, because they both are compatible
% within the Major range by semver definition.

There also exists a procedure for releases that are not backwards-compatible despite their version
number satisfying it, called \textit{yanking}. The yanked release of a package is not
deleted as it may be in use by some projects, but forces a version increment against its own number
whenever the next version is released. The resolver ignores yanked package versions unless they are
already present in the \texttt{Cargo.lock} file. While there are many reasons behind packages being
yanked, one of the main causes remains breaking semver.

\section{Abstract syntax tree (AST)}

An abstract syntax tree represents the abstract syntactic structure of the text (often source code)
in form of a tree, where every node denotes an occurence of some construct in it. The tree is
called ``abstract'', because it omits some syntax details, such as parantheses or if statements,
and focuses on structural or contextual details.

% In most of the well-established programming languages, semver validation is incredibly difficult
% or even close to impossible. This is caused by the general lack of attention to semver during
% their design processes. One of the possible approaches to cope with these difficulties is to try
% detecting semver violations by looking at the abstract syntax tree of a language. Such trees of
% a particular language might be changed along with its development, what makes maintenance of this
% solution very time-consuming. Moreover, the work itself is pretty tedious and conceptually
% challenging since to check for semver violations one needs to work on the two trees at a time.
% To make matters worse, the tree sometimes changes without violating semver.

% However, in some of the languages the problem becomes easier to handle. The Elm language was
% created with semver validation in mind, and its package manager enforces semver on the users.
% In the Rust language, there are some features that make semver validation easier. For example,
% there are crates that expose the language's abstract syntax tree. There is also a feature called
% \textit{rustdoc}, which exports all of the crate's public API into an accessible form (both human-
% and machine-readable). Thanks to these, the semver validation problem seems particularily managable
% in Rust, and there are some attempts addressing the issue already (mentioned in chapter
% \ref{r:chapter_stateoftheart}).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%          State of the art           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{State of the art}\label{r:chapter_stateoftheart}

\section{Problems with using semver in Rust}\label{r:section_usageofsemver}

It might seem easy to maintain semver, but some violations are hard to notice
when not actively searching for them. Let's look at an example.
\vspace{-3pt}
\begin{verbatim}
  struct Foo {
      x: String
  }

  pub struct Bar {
      y: Foo
  }
\end{verbatim}
\vspace{-5pt}

Changing {\ttfamily Foo.x} type from {\ttfamily String} to {\ttfamily Rc<str>}
causes semver break, even though it is a non-public field of a non-public struct.
That's because {\ttfamily String} implements {\ttfamily Send} and {\ttfamily Sync} traits
that are automatically derived, making both {\ttfamily Foo} and {\ttfamily Bar}
implement {\ttfamily Send} and {\ttfamily Sync}.
In contrary, {\ttfamily Rc<str>} implements neither of them,
so the change results in publicly visible struct {\ttfamily Bar} losing a trait.

The given example is not only non-obvious, but also is even harder to notice
in large codebases, where those struct could be in very different locations.
In fact, a similar error crept into release v3.2.0 of a well-known crate
maintained by the Rust team -- {\ttfamily clap}.
More of that later on in section \ref{r:section_real_life_semver_breaks}.
% TODO: add another example
It should be clear by now, that breaking semver on accident is possible.

\section{Consequences of breaking semver}

When you publish a new version of a crate that is breaking semver,
you are causing a major inconvenience for the crate's users.
Their code might just stop compiling when the offending version gets downloaded.
This also could happen if the crate containing violation is not an immediate dependency,
so one semver break could result in tons of broken crates.

Debugging a cryptic compilation error that starts showing up one day,
without any change to the code, can be really frustrating. Actually, we have experienced it during our contributions, as one of the dependencies broke semver. This is a major problem, as it might drive the users to stop using your crate.

Because of that, maintainers have to yank
the incorrect releases as soon as possible
-- otherwise more users would encounter this problem and their trust
in this crate (and crates using it as a dependency)
would decrease. Even though yanking the release seems easy, fixing the semver break could also result in a lot of additional work for the maintainers -- they have to investigate the semver break when it is reported, inform the users about the yanking and possibly help some move away from the faulty release.

\section{Real-life examples of semver breaks} \label{r:section_real_life_semver_breaks}

Some of popular Rust crates with millions of downloads happened to break semver:
\begin{itemize}
    \item {\ttfamily pyo3 v0.5.1} accidentally changed a function signature\footnote{https://github.com/PyO3/pyo3/issues/285},
    \item {\ttfamily clap v3.2.0} accidentally had a type stop implementing an auto-trait\footnote{https://github.com/clap-rs/clap/issues/3876},
    \item multiple {\ttfamily block-buffer} versions accidentally broke their MSRV contract\footnote{https://github.com/RustCrypto/utils/issues/22},
    \item and many more. We have developed a script that scans all releases
		for semver breaks we can detect. The results are covered in section \ref{r:section_scanning_script}
\end{itemize}

Those were examples of popular crates with experienced maintainers, but the problem is even more prominent in less popular crates
where developers might not know the common semver pitfalls. A paper\footnote{https://arxiv.org/pdf/2201.11821.pdf}
claims that out of the yanked (un-publised) releases,
semver break was the leading reason for yanking, with a shocking 43\% rate.
It also mentions that 3.7\% of all releases (and there is more than 300 000 of them already),
are yanked, which shows the scale of the problem -- thousands of detected semver breaks.

\section{Existing tools for detecting semver breaks}\label{r:section_existing_semver_tools}

There aren't many great existing tools for semver checking.
The main reason for that is that the semantics of popular languages
do not allow for complete automatic verification.
There are some initiatives to combat this. For example,
the Elm languge\footnote{https://elm-lang.org/} by design enforces semantic versioning.
Its type system enables automatic detection of all API changes.
Outside of that, it does not appear that tools for checking semver
in estabilished languages like Python or C++ are commonly used in the industry.

Unfortunately, the Rust langugage's semantic were also not designed with semver in mind.
Despite this, there are some existing tools for semver checking.
First of them, \texttt{cargo-breaking}, works on the abstract syntax tree.
The problem here is that to compare API changes, you must navigate two trees at once,
which can get really complex and tedious (especially when checking for moved or removed items), because the abstract syntax tree could change quite a lot,
even without any public API changes.
Another issue is that both language syntax and the structure of the abstract syntax tree
often change along with the development of the language, which makes maintenance time-consuming.

The second existing tool is \texttt{rust-semverver}, which focuses on
the metadata present in the rust-specific rlib binary static library format.
Because of that, unfortunately, the user experience is far from ideal,
as it forces the user to use some specific unstable versions of the language, and the quality of error messages is limited.

In comparsion, the cargo-semver-checks' approach to write lints as queries, seems to work really well.
Adding new queries is designed to be quite accessible, and the maintenance comes to
keeping up with rustdoc API changes, which seems to be about as low effort as it could be.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%               Vision                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Vision}\label{r:chapter_vision}

\section{Project purpose}

We have taken part in the development of \texttt{cargo-semver-checks}
-- a tool meant to detect semver breaks of a Rust project before publishing
its new version to the registry.
The main goal of the project is to reduce the number of issues with new releases
of libraries, which would deepen the Rust community's trust
in the packages they are using and in the whole ecosystem.

The tool is \textit{not} meant to detect all possible semver breaks.
Instead, the detection mechanism and existing lints are written
with a strong focus on finding only true-positives.
Each false-positive (which is defined as a scenario where the tool
wrongly reports a semver break) is perceived as a bug in the tool.
There are two advantages with this approach:
\begin{itemize}
	\item the tool is suited to be used in continuous integration
		for finding semver issues in commits or Pull Requests
		-- it reports semver breaks only when
		its output should not be ignored and requires manual inspection,
	\item we're avoiding a scenario in which
		a user encounters false-positives, they become frustated
		and their trust in the tool is reduced, making them
		less likely to use the tool again.
\end{itemize}

Similarly to the Rust compiler, the reports contain
detailed information about the issues, including
the line of code in which each one was found, both short and long description
of the triggered lint and, if possible, reference links to the Rust documentation
describing the semver issue in more detail.

\section{Plans to merge the tool into cargo}

There are already on-going plans to merge cargo-semver-checks into
the official Rust development toolchain,
which has been initiated by one of the developers working on cargo \cite{issue-merge-cargo}.
That would make the tool available to all Rust programmers
through a cargo subcommand and would be a huge step towards reducing the number of
package releases with semver issues.

Because of those plans, the commandline interface of the project is similar
to the interface of cargo's subcommands. Additionally, cargo developers
take part in discussions about the design of the interface \cite{issue-cli-interface}
or sometimes even review changes to the code or develop new functionalities.

It is cargo-semver-checks that was chosen to be merged into cargo,
not the other semver issues detecting tools,
mainly because it is the easiest to maintain
(as described in \ref{r:section_existing_semver_tools})
and doesn't report false-positives.

\section{Project usage}

The basic functionality of the tool is to compare two versions of the code
(the ,,current'' crate and the ,,baseline'' crate)
and notify the user about the semver issues that were found when checking the two versions.

One can run the tool by directly passing the path to the current crate
and either getting the baseline crate from registry, or by directly passing
a path to the baseline crate.

Because a large portion of libraries are currently developed using GitHub,
we are also providing a continuous integration job
via GitHub Actions to automatically ensure that
a Pull Request satisfies semver.

\subsection{Running locally}

The tool can be used on a local copy of the project
(for example, just before releasing its new version to the registry
through \texttt{cargo publish})
by passing the path to its manifest.
The baseline crate can be passed in a similar manner,
but alternatively it's possible to either
specify a version of the crate in the registry with which the
current crate should be compared with, or
(assuming that the current directory is a git repository)
by passing a git revision where the baseline project is located.

Additionally, it is possible to check all crates in a workspace
(which is a collection of crates)
one by one
by passing the path to the manifest that defines the workspace.

\subsection{Usage in continuous integration}

Seeing that GitHub is the most popular internet hosting service for version control
amongst the Rust libraries developers,
one of the goals of the project is to implement a GitHub Action
that checks whether a given git branch hasn't violated semver with recent changes.

There are two reasons as to why this continuous integration job is beneficial for the developers:
\begin{itemize}
	\item it can be used together with a job that automatically publishes a new version of the library
		when it passes the semver lints and the version of the package has been raised
		in the manifest file,
	\item it provides important information for library maintainers for deciding when
		a Pull Request should be merged -- in case the branch contains a minor or major change,
		the maintainers could want to wait with merging it until they plan to make
		a minor or major release of their library.
\end{itemize}

TODO:
\begin{itemize}
	\item ask Mieszko to check this section
\end{itemize}

\section{Project baseline}

Before our contributions, the project was already partially functional,
but it had numerous issues which often prevented the community from adopting the tool
into their workflow:
\begin{itemize}
	\item the project didn't have many lints,
	\item the code was bugged in multiple ways and lacked some functionality,
	\item the community wasn't satisfied with the implemented GitHub Action to the point where
		some developers coded their own continuous integration job using just the command-line interface of the tool,
	\item some existing lints had false-positives,
	\item the codebase was not in a state where new contributors could easily begin making changes
		to the project (which is crucial for the project to flourish in the long term).
		For example, adding new lints and tests wasn't intuitive and required many manual steps,
		the filenames and variable names were not always descriptive enough
		and the code lacked comments that explained some of the logic and decisions behind it.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%               Theory                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Theory}\label{r:chapter_theory}

\section{Project structure}\label{r:section_projectstructure}

TODO:
\begin{itemize}
	\item explain that the tool heavily uses rustdocs
	\item explain that it parses rustdoc through Trustfall
	\item define Trustfall
	\item explain how the lints look like
	\item mention that the project is split into three sub-projects,
		in this order: cargo-semver-checks, trustfall-rustdoc-adapter, trustfall-rustdoc,
		cargo-semver-checks-action,
		and briefly define what they do (like in our docs)
\end{itemize}

\section{cargo-semver-checks}

TODO:
\begin{itemize}
	\item describe in detail what is the job of cargo-semver-checks, without the adapters
	\item describe its different usages and how they retrieve the necessary data
\end{itemize}

\section{trustfall-rustdoc-adapter}

TODO:
\begin{itemize}
	\item describe the purpose of the rustdoc adapter
	\item mention what a Trustfall must implmement and that the rustdoc adapter
	\item describe what the adapter does and how trustfall-rustdoc-adapter achieves that
\end{itemize}

\section{trustfall-adapter}

TODO:
\begin{itemize}
	\item describe the purpose of the adapter and what it does
\end{itemize}

\section{cargo-semver-checks-action}

TODO:
\begin{itemize}
	\item describe the purpose of this subproject and what it does
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%           Implementation            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Implementation}\label{r:chapter_implementation}

TODO:
\begin{itemize}
	\item change names to ,,why users care about this''
\end{itemize}

\section{New lints}

<Here write a list about the new lints we've written>

\section{Test suite}

<Here write a list about the improvements in the testing suite>

\section{Command line interface}

<Here write a list about changes that made the command line interface better>

\section{Bugfixes}

<Here write a list about found and fixed bugs>

\section{Continuous integration improvements}

<Here write a list about the V2 of the continuous integration>

\section{Script}

<Here write about the script that searches all existing releases for detected semver breaks>

\section{Healthier codebase}

<Here write a list of changes that made the codebase better>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             Evaluation              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation}\label{r:chapter_evaluation}

\section{Steady increase in tool's popularity}

TODO:
\begin{itemize}
	\item show how the number of downloads has changed
	\item show how the number of stars on GitHub has changed
	\item describe how our work might have impacted those results
	\item show the comments of users on GitHub.
		As one of the examples, give the maintainer of a big
		library that created an issue ,,Make continuous integration runs faster''
		and after learning about one of our PRs to make the continuous integration faster,
		he was so excited that he wrote a comment with a tip in our PR.
		Search also for other such examples in the PRs and issues.
	\item list the maintainers of big libraries that started using the tool during our development
\end{itemize}

\section{Script} \label{r:section_scanning_script}

TODO:
\begin{itemize}
        \item adjust the name of the subsection
        \item show the results of the script that searches all existing releases for detected semver breaks
	\item describe how our new lints can make an impact on the community based on the found semver breaks from the script
\end{itemize}

\section{Future-proofing}

TODO:
\begin{itemize}
	\item describe other overall changes that prepares the tool to be more successful in the future
	\item describe how the code changed to be more welcoming for next contributors
\end{itemize}

\section{Conclusion}

TODO:
\begin{itemize}
	\item write a conclusion
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                Team                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Team}\label{r:chapter_team}

\section{Used methodology}

TODO:
\begin{itemize}
	\item describe how we've been developing the tool
	\item describe our mentor's reviews
	\item describe how initially we splitted our work and how we did it later
\end{itemize}

\section{Responsibilities}

TODO:
\begin{itemize}
	\item describe who did what
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%            Bibliography             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix

\begin{thebibliography}{99}\label{r:chapter_bibliography}
\addcontentsline{toc}{chapter}{Bibliography}

% \bibitem[Bea65]{beaman} Juliusz Beaman, \textit{Morbidity of the Jolly
%     function}, Mathematica Absurdica, 117 (1965) 338--9.
\bibitem{issue-merge-cargo} \href{}{GitHub cargo-semver-checks issue \#61: Prepare for merging into cargo}
\bibitem{issue-cli-interface} \href{}{GitHub cargo-semver-checks issue \#86 What should the CLI look like?}

\bibitem{Rust-1} Rust Team,
	\textit{Rust Programming Language} (2023) \\
	https://www.rust-lang.org/

\bibitem{Rust-2} Wikipedia,
	\textit{Rust (programming language)} (2023) \\
	https://en.wikipedia.org/wiki/Rust\_(programming\_language)/

\bibitem{survey} Stack Overflow,
	\textit{Annual Developer Survey} (2022) \\
	https://insights.stackoverflow.com/survey/

\bibitem{Rust-for-Linux} Wikipedia,
	\textit{Rust for Linux} (2023) \\
	https://en.wikipedia.org/wiki/Rust\_for\_Linux/

\bibitem{Cargo} Rust Team,
	\textit{The Cargo Book} (2023) \\
	https://doc.rust-lang.org/cargo/index.html/

\bibitem{Cargo-vs-pip} William Manley,
	\textit{Pip and Cargo are not the same} (2022) \\
	https://doc.rust-lang.org/cargo/index.html/

\bibitem{Abstract-Syntax-Tree} Wikipedia,
	\textit{Abstract syntax tree} (2023) \\
	https://en.wikipedia.org/wiki/Abstract\_syntax\_tree/

\bibitem{Semantic-Versioning} semver.org,
	\textit{Semantic Versioning 2.0.0} (2022) \\
	https://semver.org/

% State of the art references:
\bibitem[1]{beaman} Predrag Gruevski,
    \textit{Towards fearless cargo update} (2022) \\
    https://predr.ag/blog/toward-fearless-cargo-update/

\end{thebibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             Attachments             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter*{Attachments}\label{r:chapter_attachments}
\addcontentsline{toc}{chapter}{Attachments}

\section*{Source code structure}

<Here describe the project structure of the included CD>


\section*{Tests}

<Here describe the tests (and possibly how to run them) of the included CD>

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-2
%%% End:
