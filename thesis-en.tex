\documentclass[licencjacka,en]{pracamgr}
\usepackage{hyperref}

\autor{Tomasz Nowak}{429575}
\autori{Michał Staniewski}{429598}
\autorii{Mieszko Grodzicki}{429132}
\autoriii{Bartosz Smolarczyk}{429594}
\opiekun{mgr Michał Możdżonek\\
  Institute of Informatics\\
  }
\date{May 2023}
\kierunek{Computer Science}
% Wg klasyfikacji Socrates-Erasmus:
\dziedzina{
11.3 Computer Science\\
}
% Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
\klasyfikacja{
  D. Software\\
  D.2. Software Engineering\\
  D.2.4. Software/Program Verification
  }

\title{Accelerating package expansion in Rust through development of a semantic versioning tool}
\titlepl{Przyspieszenie rozwoju pakietów w języku Rust poprzez rozbudowę narzędzia do
	semantycznego wersjonowania}
\keywords{Rust, semantic versioning, continuous integration, package manager}

\begin{document}
\maketitle

\begin{abstract}
In many programming languages there exist countless nuances, making developers accidentally release
new versions of their packages that are not backwards-compatible. Such releases can directly impact
projects which are using their packages, causing bugs or even compilation errors when using the
latest version. One of the affected languages is Rust, which also lacks (itself) a built-in
mechanism for enforcing semantic versioning.

The aim of this thesis is to describe the development of a tool for Rust programmers to reduce the
chances of publishing a new version of the code that violates semantic versioning.

There are already on-going plans to bundle this tool into the language's standard
development toolchain. It would make it commonly used and therefore help users to safely get
bug fixes, security patches and new functionality, without worrying about their app being broken
by a dependency change.
\end{abstract}

% Abstrakt po polsku (potrzebny tylko w APD?)
% W wielu językach programowania istnieją liczne niuanse sprawiające, że deweloperzy omyłkowo
% publikują nowe wersje swoich pakietów bez zachowania kompatybilności wstecznej. Takie sytuacje
% mogą bezpośrednio wpłynąć na projekty korzystające z ich pakietów, powodując błędy bądź nawet
% uniemożliwiając kompilację po aktualizacji do najnowszej wersji. Jednym z języków dotkniętych
% tym problemem jest Rust, który nie posiada wbudowanego mechanizmu wymuszającego
% semantyczne wersjonowanie.

% Celem tej pracy jest przedstawienie rozwoju narzędzia dla języka Rust, które zmniejsza ryzyko
% publikacji kodu nieprzestrzegającego zasad semantycznego wersjonowania.

% Są również plany, aby narzędzie to stało się częścią standardowego toolchainu deweloperskiego.
% Skutkowałoby to jego powszechnym użyciem i tym samym zagwarantowałoby użytkownikom, że korzystanie
% z poprawek błędów, łatek bezpieczeństwa oraz nowych funkcjonalności pakietów nie doprowadzi do
% awarii ich aplikacji.

\tableofcontents
%\listoffigures
%\listoftables

\chapter*{Executive summary}
\addcontentsline{toc}{chapter}{Executive summary}

TODO:
\begin{itemize}
	\item write the executive summary (around one page long)
	\item describe in short what is the goal of the project and what it solves
	\item describe that the project is indeed needed
	\item mention what we've done and how it moved the project towards the vision
	\item mention the results and the impact on the community
\end{itemize}

\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

Rust is a relatively new language that has lately been gaining on popularity. Amongst its standard
development toolchain there is a software called cargo -- Rust's build system and package manager,
which handles building a crate -- a package with Rust code. One of cargo's responsibilities is to
search for the newest crate versions, download them and build dependencies (that is, other
libraries / crates that the code uses).

Cargo assumes that all crates follow semantic versioning -- a set of rules that decide when it is
safe to use the new version of a library without any problems (the projects that depend on this
library must still compile). Thanks to that, developers of libraries can release patches and
bugfixes and cargo by default will automatically use those newest releases. The exact definition of
semantic versioning is explained in chapter \ref{r:chapter_definitions}.

It turns out that it is not obvious which changes are backwards-compatible and which are not.
There are numerous examples (listed in \ref{r:section_usageofsemver}) where experienced Rust
developers made a mistake (due to insufficient knowledge about the language or by overlooking
something) that changed the public API (Application Programming Interface) of a library in such
a way that users' code stopped compiling.

The authors of this thesis present their work on a tool that detects and notifies about a subset of
problems that make Rust libraries' public API non-backwards compatible, with the goal to make
problems with semantic versioning less frequent in the Rust community. The exact goals of this
project are described in chapter \ref{r:chapter_vision}.

The project is open-source -- all of the authors' work is visible in public repositories (listed in
\ref{r:section_projectstructure}). The project existed before their contributions, thus chapter
\ref{r:chapter_implementation} mainly describes how they have extended the project's
functionalities and fixed its issues. Chapter \ref{r:chapter_evaluation} is a summary of their
results and the project's impact on the Rust community.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             Definitions             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Definitions}\label{r:chapter_definitions}

\section{Rust language}

With its first stable release in 2015, Rust is a relatively new programming language that
puts a strong emphasis on type-safety, memory-safety, performance and concurrency. Unlike
other memory-safe languages, Rust does not use reference counting nor a garbage collector.
Instead it tracks the object lifetime of all the program's references during compilation,
using its built-in mechanism named ``borrow checker''.

Among many benefits and advantages of using Rust, there are three dominant features. Firstly,
it provides the user with a great performance, both time- and memory-wise, allowing for
writing efficient applications. Secondly, it is reliable -- with extensive type system and
focus on runtime safety, Rust prevents the user from making multiple bugs
already during compilation. Finally, it boosts productivity -- its documentation is
comprehensive and the compiler's error messages are clear and helpful. Rust also provides
an easy to use, integrated package manager and a dedicated build tool (named cargo),
an auto-formatter and many more.

According to surveys \cite{survey} conducted amongst developers, Rust is considered to be the most
enjoyable programming language for the 7th year in a row (as of 2022 summary, meaning it was always
on top since its release in 2015). Over 87\% of respondents who have previously used Rust would
like to continue programming in it.

Because of the high level of safety it provides, Rust has also become the secondary
language for writing the Linux kernel (with the primary being C). While there have been
attempts to add other languages (f.e. C++ in 1997), Rust is the first one to successfully
make it since the kernel's first release in 1991.

\section{Rust's package manager and build system -- cargo}

Cargo is the official package manager for Rust. It is responsible for compiling the user's
packages, downloading their dependencies and uploading them to the selected package registry.
It is important to note that in Rust, packages are often refered to as \texttt{crates} with both
names being equivalent and commonly used. Most of the currently publicly available crates are
stored in the Rust community's default crate registry, \texttt{crates.io}. The role of the
registries is to allow users to easily find appropriate crates for their projects, as well as
publish their own work to be used by others. Each registry contains an index, which itself has
a searchable list of all the crates available within its registry. Cargo uses the selected registry
and index to download crates and update dependencies.

One can think of cargo as the Rust analogue of Python's pip (the official package manager for
Python, responsible for handling all \texttt{import} statements). But despite their similar roles,
cargo has many advantages making it a lot safer than pip:
\begin{itemize}
	\item Cargo's crates are always installed using virtual environments, thus they cannot be
		installed in a location that would interfere with unrelated code.
	\item When a user adds a crate to their project, they can only use its direct, public interface.
		There is no possibility to access the interfaces of the dependencies that the added crate
		is using itself.
	\item The dependency's name must also be included in a special file named \texttt{Cargo.toml},
		not just in the source code file.
	\item To make the package's public interface explicit, Rust provides a series of tools for
		privacy management. Because of this, it is much more difficult for the user to make their
		project depend on something that the package's author did not intend to offer and could
		make private in future versions, causing a difficult to detect break on the user's end.
	\item Compatibility is taken seriously in Rust, thus packages' APIs (Applications Programming
		Interfaces) are expected to be backwards-compatible (and to follow semantic versioning,
		described in section \ref{r:section_semver}) when a new version is released. When a package
		does not satisfy this requirement, there exists a procedure called \textit{yanking}.
		It allows to remove the faulty version from the index without deleting any data, but moves
		the index back to the most recent working version. Yet in case an incompatible package is
		downloaded before being yanked, projects using the package still mostly break during
		compilation or build time rather than runtime.
	\item The packages are also written in Rust and never require anything to work other than the
		package code itself. This minimizes the threat of missing pre-installed
		system dependencies.
	\item Cargo allows for an executable to contain different versions of the same package,
		enabling the user to include multiple dependencies based on a shared sub-dependency.
		When multiple versions of the sub-dependency are required, they are all included
		without conflicts.
\end{itemize}

Each package in Rust contains a special \texttt{Cargo.toml} file, called \textit{manifest}. It is
written in the TOML format for simplicity and contains all the metadata necessary for the package
to compile. Every manifest has numerous sections, with the most important two being:
\begin{itemize}
	\item \texttt{[package]} -- contains the information for cargo to compile the package.
		The minimum that must be provided are the package's name and version. Additional fields
		may be required when the maintainer wants to share their work with others by publishing
		to a registry.
	\item \texttt{[dependencies]} -- lists all of the package's dependencies. Before compiling,
		cargo has to search for and download all of them. The default search location is crates.io.
\end{itemize}
Presence of the manifest file allows the crates.io registry to display useful information about
a particular package. The users are provided with a \texttt{README.md} file, instructions on how
to add the package to their own Cargo.toml file, a list of all available versions, statistics
regarding the downloads for each version and more.

There also exists a second file for cargo -- \texttt{Cargo.lock}. It contains detailed
information about the used dependencies. Since all dependencies come from some version control
system, the user may not need to provide an exact revision of a dependency in their
\texttt{Cargo.toml} file. In this case, there are two scenarios for what happens with the
\texttt{Cargo.lock} file during compilation:
\begin{itemize}
	\item \texttt{Cargo.lock} is \textit{not} present -- cargo then creates it and for each
		dependency in the manifest downloads the most recent revision available, saving additional
		data about it in the file.
	\item \texttt{Cargo.lock} is present -- for the dependencies already present in the file, cargo
		does not look for their newest version and instead downloads the one specified in the file.
		For dependencies that are not present, it does the same as above except it adds them to
		the file rather than overwrites it.
\end{itemize}
There is a dedicated command for updating the dependencies -- \texttt{cargo update}.
Upon execution, the \texttt{Cargo.lock} file is either created or updated with the latest
revisions of used dependencies.

Besides downloading dependencies, users can also publish their own packages using
the \texttt{cargo publish} command. To use the command, the user must first authenticate with
an API token. After doing so, the command first performs preliminary checks, including searching
the manifest for a key to determine whether the user is allowed to upload their package
to the selected registry (by default crates.io). Once the checks are passed, the package is
uploaded and available publicly.

\section{Semantic versioning (semver)}\label{r:section_semver}

Semantic versioning is a set of rules and requirements dictating how version numbers for packages
are assigned and incremented. They are based on, but not limited to currently widely used
practices in both open-source and closed software development. For these rules to work, one has to
first declare a clear and precise public API, changes of which refer to specific incrementations of
the package version number. The number is most often denoted as X.Y.Z (Major.Minor.Patch), where:
\begin{itemize}
	\item \textbf{Major} number is incremented when backwards-incompatible API changes were made,
	\item \textbf{Minor} number is incremented when a functionality was added in
		a backwards-compatible manner,
	\item \textbf{Patch} number is incremented when backwards-compatible bugfixes were made.
\end{itemize}
With these rules, version numbers and their changes reflect actions in the underlying
package's code. By definition, two versions are considered compatible if their leftmost non-zero
component remains unchanged.

The main purpose of semantic versioning is to track the changes of a package's API and reflect
their severity with appropriate numbering.
When systems with multiple dependencies are considered, the lack of semver can have serious
consequences. If the dependency rules are too tight, one is in danger of facing a version lock
(inability to release a new version of one package without new versions of all packages depending
on it). On the other hand, if the rules are too loose, there is a risk of version promiscuity
(assuring that currently released version will be compatible with too many future releases).
Without semver, such issues can occur and make it difficult for developers to further expand
their projects.

In Rust, semver is used by cargo for specifying package version numbers. This makes for a common
compatibility convention between different versions of the same package. Cargo assumes that
it is safe to update a dependency within a compatibility range without it breaking the build.
This range can be defined in the manifest using the \textit{version requirement syntax}, allowing
the user to select the upper bound for maximum compatible number anywhere from one, specific
version (not allowing any updates), to no limit at all (equivalent to allowing even major updates).
The default behaviour is to update until the next major version.

% When updating, if multiple packages share a dependency, cargo's resolver attempts to ensure
% that they use as few versions of it as possible (ideally all packages may share a dependency
% version), while ensuring none of them is forced to use a version outside of their compatibility
% range. At the same time, the resolver tries to use the greatest version currently available within
% that range. However, the resolver does not allow to use multiple versions of a package within the
% same compatibility range and returns an error. For example, it is not possible to use two versions
% of a package with the same Major and different Minor numbers, because they both are compatible
% within the Major range by semver definition.

There also exists a procedure for releases that are not backwards-compatible despite their version
number satisfying it, called \textit{yanking}. The yanked release of a package is not
deleted as it may be in use by some projects, but forces a version increment against its own number
whenever the next version is released. The resolver ignores yanked package versions unless they are
already present in the \texttt{Cargo.lock} file. While there are many reasons behind packages being
yanked, one of the main causes remains breaking semver.

\section{Abstract syntax tree (AST)}

An abstract syntax tree represents the abstract syntactic structure of the text (often source code)
in form of a tree, where every node denotes an occurence of some construct in it. The tree is
called ``abstract'', because it omits some syntax details, such as parantheses or if statements,
and focuses on structural or contextual details.

% In most of the well-established programming languages, semver validation is incredibly difficult
% or even close to impossible. This is caused by the general lack of attention to semver during
% their design processes. One of the possible approaches to cope with these difficulties is to try
% detecting semver violations by looking at the abstract syntax tree of a language. Such trees of
% a particular language might be changed along with its development, what makes maintenance of this
% solution very time-consuming. Moreover, the work itself is pretty tedious and conceptually
% challenging since to check for semver violations one needs to work on the two trees at a time.
% To make matters worse, the tree sometimes changes without violating semver.

% However, in some of the languages the problem becomes easier to handle. The Elm language was
% created with semver validation in mind, and its package manager enforces semver on the users.
% In the Rust language, there are some features that make semver validation easier. For example,
% there are crates that expose the language's abstract syntax tree. There is also a feature called
% \textit{rustdoc}, which exports all of the crate's public API into an accessible form (both human-
% and machine-readable). Thanks to these, the semver validation problem seems particularily managable
% in Rust, and there are some attempts addressing the issue already (mentioned in chapter
% \ref{r:chapter_stateoftheart}).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%          State of the art           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{State of the art}\label{r:chapter_stateoftheart}

\section{Problems with using semver in Rust}\label{r:section_usageofsemver}

It might seem easy to maintain semver, but some violations are hard to notice
when not actively searched for. Consider the following example:
\vspace{-3pt}
\begin{verbatim}
  struct Foo {
      x: String
  }

  pub struct Bar {
      y: Foo
  }
\end{verbatim}
\vspace{-5pt}

Changing {\ttfamily Foo.x} type from {\ttfamily String} to {\ttfamily Rc<str>}
causes semver break, even though it is a non-public field of a non-public struct.
That is because {\ttfamily String} implements {\ttfamily Send} and {\ttfamily Sync} traits
that are automatically derived, making both {\ttfamily Foo} and {\ttfamily Bar}
implement {\ttfamily Send} and {\ttfamily Sync}.
In contrary, {\ttfamily Rc<str>} implements neither of them,
so the change results in a publicly visible struct {\ttfamily Bar} losing a trait.

The given example is not only unobvious, but also even harder to notice in large codebases, where
those structs could be in completely different locations. In fact, a similar error crept into the
release v3.2.0 of a well-known crate maintained by the Rust team -- {\ttfamily clap}. More details
about it can be found in section \ref{r:section_real_life_semver_breaks}.

The same issue almost happened (but has been prevented thanks to our tool) in another common
library \texttt{rust-libp2p}, where it is clear from the conversation \cite{issue_libp2p} that
the maintainers were not expecting their type to stop being \texttt{UnwindSafe} and were likely
not even aware that their type was publicly \texttt{UnwindSafe} to start with.

\section{Consequences of breaking semver}

When a maintainer publishes a new version of their crate that is breaking semver,
it is causing a major inconvenience for the crate's users.
Their code might just stop compiling when the offending version gets downloaded.
This could also happen if the crate containing the violation is not an immediate dependency,
so one semver break could result in tons of other broken crates.

Debugging a cryptic compilation error that starts showing up one day,
without any change to the code, can be frustrating. In fact, we have experienced it during our
contributions (one of the tool's users opened a GitHub Issue \cite{issue_compiling_fails}), as one
of our dependencies broke semver. This is a major problem, as it might drive the users to stop
using such crate.

Because of that, maintainers have to yank the incorrect releases as soon as possible -- otherwise
more users would encounter this problem and their trust in this particular crate (and crates using
it as a dependency) would decrease. Even though yanking the release seems easy, fixing the semver
break could also result in a lot of additional work for the maintainers -- they have to investigate
the semver break when it is reported, inform the users about the yanking and possibly help some
move away from the faulty release.

\section{Real-life examples of semver breaks} \label{r:section_real_life_semver_breaks}

Some of popular Rust crates with millions of downloads happened to break semver:
\begin{itemize}
    \item {\ttfamily pyo3 v0.5.1} accidentally changed a function signature \cite{pyo3-issue}
    \item {\ttfamily clap v3.2.0} accidentally had a type stop implementing an auto-trait
		\cite{clap-issue}
    \item multiple {\ttfamily block-buffer} versions accidentally broke their MSRV contract
		\cite{block-buffer-issue}
    \item and many more. We have developed a script that scans all releases for semver breaks we
		can detect. The results are covered in section \ref{r:section_scanning_script}
\end{itemize}

Those were examples of popular crates with experienced maintainers, but the problem is even more
prominent in less used crates where developers might not know the common semver pitfalls. A paper
\cite{paper} claims that out of the yanked (un-publised) releases, semver break was the leading
reason for yanking, with a shocking 43\% rate. It also mentions that 3.7\% of all releases
(and there is more than 300 000 of them already) are yanked, which shows the scale of the problem
-- thousands of detected semver breaks.

\section{Existing tools for detecting semver breaks}\label{r:section_existing_semver_tools}

There are not many great tools for semver checking in existence. The main reason for that is that
the semantics of popular languages make complete and automatic verification practically impossible.
There are some initiatives to combat this. For example, the Elm languge\cite{elm-lang} by design
enforces semantic versioning. Its type system enables automatic detection of all API changes.
Outside of that, it does not appear that tools for checking semver in estabilished languages like
Python or C++ are commonly used in the industry.

Unfortunately, the Rust language's semantics were also not designed with semver in mind.
Despite this, there are some existing tools for semver checking. First of them,
\texttt{cargo-breaking}, works on the abstract syntax tree. Although ASTs contain all the
information needed for comparing API changes, it has a major drawback -- two trees must be
navigated at once. It can get complex and tedious (especially when checking for moved or removed
items), because the abstract syntax tree could change quite a lot, even without any public API
changes. Another issue is that both language syntax and the structure of the abstract syntax tree
often change along with the development of the language, which makes maintenance time-consuming.

The second existing tool is \texttt{rust-semverver}, which focuses on the metadata present in the
rust-specific rlib binary static library format. Because of that, the user experience is far from
ideal, as it forces the user to use some specific unstable versions of the language, and the
quality of error messages is limited.

In comparison, the cargo-semver-checks' approach to write lints as queries seems to work
really well. Adding new queries is designed to be accessible and the maintenance comes down to
keeping up with rustdoc API changes, which seems to be about as low effort as it could be.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%               Vision                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Vision}\label{r:chapter_vision}

\section{Project purpose}

We have taken part in the development of \texttt{cargo-semver-checks} -- a tool meant to detect
semver breaks of a Rust project before publishing its new version to the registry. The main goal
of the project is to reduce the number of issues with new releases of libraries, which would deepen
the Rust community's trust in the packages they are using and in the whole ecosystem.

The tool is \textit{not} meant to detect all possible semver breaks. Instead, the detection
mechanism and existing lints are written with a strong focus on finding only true-positives.
Each false-positive (which is defined as a scenario where the tool wrongly reports a semver break)
is perceived as a bug in the tool. There are two advantages with this approach:
\begin{itemize}
	\item the tool is suited to be used in continuous integration for finding semver issues in
		commits or Pull Requests -- it reports semver breaks only when its output should not be
		ignored and requires manual inspection,
	\item we're avoiding a scenario in which a user encounters false-positives, they become
		frustated and their trust in the tool is reduced, making them less likely to use the
		tool again.
\end{itemize}

Similarly to the Rust compiler, the reports contain detailed information about the issues,
including the line of code in which each one was found, both short and long description of the
triggered lint and, if possible, reference links to the Rust documentation describing the semver
issue in more detail.

\section{Plans to merge the tool into cargo}

There are already on-going plans to merge cargo-semver-checks into the official Rust development
toolchain, which has been initiated by one of the developers working on cargo
\cite{issue_merge_cargo}. That would make the tool available to all Rust programmers through
a cargo subcommand and would be a huge step towards reducing the number of package releases with
semver issues.

Because of those plans, the commandline interface of the project is similar to the interface of
cargo's subcommands. Additionally, cargo developers take part in discussions about the design of
the interface \cite{issue_cli_interface} or sometimes even review changes to the code or develop
new functionalities.

cargo-semver-checks was the one tool chosen to be merged into cargo, mainly because it is the
easiest to maintain (as described in \ref{r:section_existing_semver_tools}) and does not report
false-positives.

\section{Project usage}

The basic functionality of the tool is to compare two versions of the code (the ,,current'' crate
and the ,,baseline'' crate) and notify the user about the semver issues that were found when
checking the two versions.

One can run the tool by directly passing the path to the current crate and either getting the
baseline crate from registry, or by directly passing a path to the baseline crate.

Because a large portion of libraries are currently developed using GitHub, we are also providing
a continuous integration job via GitHub Actions to automatically ensure that a Pull Request
satisfies semver.

\subsection{Running locally}

The tool can be used on a local copy of the project (for example, just before releasing its new
version to the registry through \texttt{cargo publish}) by passing the path to its manifest.
The baseline crate can be passed in a similar manner, but alternatively it's possible to either
specify a version of the crate in the registry with which the current crate should be compared
with, or (assuming that the current directory is a git repository) by passing a git revision where
the baseline project is located.

Additionally, it is possible to check all crates in a workspace (which is a collection of crates)
one by one by passing the path to the manifest that defines the workspace.

\subsection{Usage in continuous integration}

Seeing that GitHub is the most popular internet hosting service for version control amongst the
Rust libraries developers, one of the goals of the project is to implement a GitHub Action that
checks whether a given git branch hasn't violated semver with recent changes.

There are two reasons as to why this continuous integration job is beneficial for the developers:
\begin{itemize}
	\item it can be used together with a job that automatically publishes a new version of the
		library when it passes the semver lints and the version of the package has been raised
		in the manifest file,
	\item it provides important information for library maintainers for deciding when a Pull
		Request should be merged -- in case the branch contains a minor or major change, the
		maintainers could want to wait with merging it until they plan to make a minor or major
		release of their library.
\end{itemize}

% TODO:
% \begin{itemize}
% 	\item ask Mieszko to check this section
% \end{itemize}

\section{Project baseline}

Before our contributions, the project was already partially functional, but it had numerous issues
which often prevented the community from adopting the tool into their workflow:
\begin{itemize}
	\item the project didn't have many lints,
	\item the code was bugged in multiple ways and lacked some functionality,
	\item the community wasn't satisfied with the implemented GitHub Action to the point where some
		developers coded their own continuous integration job using just the command-line interface
		of the tool,
	\item some existing lints had false-positives,
	\item the codebase was not in a state where new contributors could easily begin making changes
		to the project (which is crucial for the project to flourish in the long term).
		For example, adding new lints and tests was not intuitive and required many manual steps,
		the filenames and variable names were not always descriptive enough and the code lacked
		comments that explained some of the logic and decisions behind it.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%               Theory                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Theory}\label{r:chapter_theory}

\section{Project structure}\label{r:section_projectstructure}

TODO:
\begin{itemize}
	\item explain that the tool heavily uses rustdocs
	\item explain that it parses rustdoc through Trustfall
	\item define Trustfall
	\item explain how the lints look like
	\item mention that the project is split into three sub-projects,
		in this order: cargo-semver-checks, trustfall-rustdoc-adapter, trustfall-rustdoc,
		cargo-semver-checks-action,
		and briefly define what they do (like in our docs)
\end{itemize}

\section{cargo-semver-checks}

TODO:
\begin{itemize}
	\item describe in detail what is the job of cargo-semver-checks, without the adapters
	\item describe its different usages and how they retrieve the necessary data
\end{itemize}

\section{trustfall-rustdoc-adapter}

TODO:
\begin{itemize}
	\item describe the purpose of the rustdoc adapter
	\item mention what a Trustfall must implmement and that the rustdoc adapter
	\item describe what the adapter does and how trustfall-rustdoc-adapter achieves that
\end{itemize}

\section{trustfall-adapter}

TODO:
\begin{itemize}
	\item describe the purpose of the adapter and what it does
\end{itemize}

\section{cargo-semver-checks-action}

TODO:
\begin{itemize}
	\item describe the purpose of this subproject and what it does
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%           Implementation            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Implementation}\label{r:chapter_implementation}

TODO:
\begin{itemize}
	\item change names to ,,why users care about this''
\end{itemize}

\section{New lints}

<Here write a list about the new lints we've written>

\section{Test suite}

<Here write a list about the improvements in the testing suite>

\section{Command line interface}

<Here write a list about changes that made the command line interface better>

\section{Bugfixes}

<Here write a list about found and fixed bugs>

\section{Continuous integration improvements}

<Here write a list about the V2 of the continuous integration>

\section{Script}

<Here write about the script that searches all existing releases for detected semver breaks>

\section{Healthier codebase}

<Here write a list of changes that made the codebase better>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             Evaluation              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation}\label{r:chapter_evaluation}

\section{Steady increase in tool's popularity}

TODO:
\begin{itemize}
	\item show how the number of downloads has changed
	\item show how the number of stars on GitHub has changed
	\item describe how our work might have impacted those results
	\item show the comments of users on GitHub.
		As one of the examples, give the maintainer of a big
		library that created an issue ,,Make continuous integration runs faster''
		and after learning about one of our PRs to make the continuous integration faster,
		he was so excited that he wrote a comment with a tip in our PR.
		Search also for other such examples in the PRs and issues.
	\item list the maintainers of big libraries that started using the tool during our development
\end{itemize}

\section{Script} \label{r:section_scanning_script}

TODO:
\begin{itemize}
        \item adjust the name of the subsection
        \item show the results of the script that searches all existing releases for detected semver breaks
	\item describe how our new lints can make an impact on the community based on the found semver breaks from the script
\end{itemize}

\section{Future-proofing}

TODO:
\begin{itemize}
	\item describe other overall changes that prepares the tool to be more successful in the future
	\item describe how the code changed to be more welcoming for next contributors
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                Team                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Team}\label{r:chapter_team}

\section{Used methodology}

The project's functionalities and goals can be split into independent improvements, hence our
contributions were mostly composed of multiple smaller changes. The usual workflow of writing
code was as follows:
\begin{enumerate}
	\item discussing with our mentor (who is also the project maintainer) about which improvements
		have the highest priority,
	\item individually picking a few tasks based on our preferences,
	\item implementing those tasks (and sometimes also thinking about the design of the change)
		and creating Pull Requests on the project's GitHub repositories,
	\item going through an extensive review process with our mentor (as there are often other
		contributors in the project besides us, the code's readability is a strong focus point
		in the project),
	\item getting the Pull Request merged by our mentor and releasing (usually a few days later)
		a new version of the binary to the registry.
\end{enumerate}

There were some exceptions to this workflow:
\begin{itemize}
	\item at the beginning, we split into two pairs and our mentor gave each of us introductory
		tasks to work on together and familiarize with different aspects of the existing code,
	\item to speedup the process of merging the Pull Requests, we sometimes reviewed each others'
		code before passing it to our mentor,
	\item when a user reported a bug, we often looked into the problem and searched for a temporary
		fix of the bug as soon as possible,
	\item when we encountered bugs or thought of possible additional improvements in the tool's
		functionality, we created an appropriate Issue on the GitHub repository.
\end{itemize}

Additionally, we held weekly meetings with the four of us to discuss the progress and future
contributions (we did not need to have regular meeting with our mentor, because we had constant
and immediate contact with him through chat).

\section{Responsibilities}

\begin{itemize}
	\item Tomasz:
		\begin{itemize}
			\item Reported a bug with an incorrect path to the generated rustdoc when passing
				a manifest path in the CLI \cite{issue_wrong_path_manifest_path}.
			\item Changed how the manifest of the baseline is built and added
				selecting all features to baseline's manifest \cite{pr_changed_how_manifest_baseline_built},
				which resolved an issue reported by a user of the tool
				\cite{issue_baseline_rustdoc_from_registry_default_features}
				where the current and baseline's rustdoc was generated with different features,
				which resulted in false-positives.
			\item Reported a bug where the tests failed on the newest version
				of the compiler \cite{issue_tests_fail_on_nightly}
				and implemented a fix \cite{pr_tests_fail_on_nightly}.
			\item Renamed directories with queries and tests, thanks to which the
				structure of the project is now clear, more intuitive
				\cite{pr_renamed_directories} \cite{pr_renamed_directories_2}
				and updated \texttt{CONTRIBUTING.md} \cite{pr_renamed_directories_3}.
			\item Replaced code duplication with a Rust macro and made adding new
				lints easier \cite{pr_one_macro}.
			\item Improved the tests \cite{pr_split_each_test},
				which speeded up the process of adding new lints.
				More precisely:
				\begin{itemize}
					\item splitted each test into separate pairs of crates
						(that are baseline and current crates for the tool),
					\item made it so that the tool runs each lint on all testing crates
						(which has detected multiple new false-positives),
					\item massively improved the readability and ease of adding new tests and lints,
					\item improved the error messages when the test output didn't match.
				\end{itemize}
			\item Made a change in the tests that runs the tool on crates that did not change
				to detect possible false-positives \cite{pr_run_lints_nonchanged_crates}.
			\item Commited changes suggested by a new version of the Rust formatter \cite{pr_clippy_lint}.
			\item Found and fixed a bug where the printed baseline version
				was incorrect \cite{pr_bugfix_printed_baseline}.
			\item Added a new type of integration tests, which locally checks
				how the tool behaves with given commandline arguments,
				and implemented a test that checks whether a recent bug
				(where the lint files were not present in the binary)
				was fixed \cite{pr_run_cargo_build}.
			\item Diagnosed a problem where the tests stopped working \cite{issue_tests_fail_unknown},
				fixed the adapter after a new rustdoc version which
				stopped exporting inlined items of external crates \cite{pr_rustdoc_trait_incompatibility}
				and created an issue for strengthening back a lint that was
				affected by those changes \cite{issue_strengthen_back}.
			\item Reported a problem where the user could be confused by the lack of
				detailed information in the help messages of the tool \cite{issue_help_messages}.
			\item Reported a problem where the output of the tool on the \texttt{bevy-audio} crate
				seemed like it was producing a false positive \cite{issue_bevy_audio}.
			\item Reported a bug where a lint's output was duplicated on the
				\texttt{bevy-render} crate \cite{issue_duplicated_failure}.
			\item Added a feature to disable the usage of the vendored \texttt{OpenSSL} \cite{pr_openssl}
				because there were problems with it amongst users having
				the Arch Linux desktop distribution \cite{issue_openssl}.
			\item Changed the way in which the rustdoc of a crate is generated
				-- instead of directly running the rustdoc command on a local copy of the crate,
				it is now ran on a temporary placeholder project,
				which just has the checked crate as a dependency.
				It solves a bug encountered by a user \cite{issue_apple_bitflags}
				where running the tool updates the \texttt{Cargo.lock} file,
				and allows to easily specify the set of crate's features to run the rustdoc command on
				\cite{pr_placeholder_1} \cite{pr_placeholder_2} \cite{pr_placeholder_3}
				\cite{pr_placeholder_4} \cite{pr_placeholder_5} \cite{pr_placeholder_6}.
				% The change was done by moving and splitting existing functions into smaller ones \cite{pr_placeholder_1},
				% switching the baseline rustdoc generation to using the new placeholder project \cite{pr_placeholder_2},
				% changing functions' arguments for better readability \cite{pr_placeholder_3},
				% renaming files for the same reason \cite{pr_placeholder_4},
				% chosing variable names that fit more nicely with the current code \cite{pr_placeholder_5}
				% and finally switching to the new rustdoc generation logic \cite{pr_placeholder_6}.
			\item Reported a bug where the tool failed to work when
				generating rustdoc of a crate that only has yanked releases \cite{issue_fails_yanked}.
			\item Reported a bug where the tool prints some internal data
				while cheching the \texttt{clap} crate \cite{issue_internal_data}.
			\item Found and fixed a bug where the CI job wrongly checked
				the exit code in one of the integration tests \cite{pr_exit_code}.
			\item Added a lint in the CI for checking the rustdoc of the project \cite{pr_ci_rustdoc}.
			\item Fixed a broken link which the users saw in the tool's output \cite{pr_broken_link}.
			\item Reported a false-positive which was related to re-exporting types, values and macros
				with the same names \cite{issue_reexporting}.
			\item Fixed a user-encountered bug where implicit features due to target-specific
				optional dependencies were not added in the current version \cite{pr_false_positive_target_specific}.
			\item Fixed a user-reported bug \cite{issue_color_always}
				where the rustdoc command's output wasn't showing up with colors \cite{pr_color_always}.
			\item Diagnosed a user-encountered compilation error which happened
				because of changes in one of the tool's dependencies \cite{issue_compiling_fails}.
			\item Took part in the development of the library based on the existing tool's code \cite{pr_library}.
		\end{itemize}

	\item Michał:
		\begin{itemize}
			\item Added a new type of tests in the CI -- a regression test
				that is checking the tool against a specific version of a user's crate,
				to be certain that now the tool works and has
				no false-positives on it \cite{pr_add_running_on_rust_libp2p}.
			\item Added a test that checks whether a field in the lints
				is correctly initialized \cite{pr_add_error_template_instantiation}.
			\item Added an integration test in the CI for specifying the package name \cite{pr_test_specifying_package_name}.
			\item Made a new release workflow in the CI that triggers when publishing
				a new version of the tool and uploads the new binaries to GitHub releases,
				thanks to which the GitHub Actions
				(both provided by us and written by users for their own purposes) that were using the tool
				can now just download the binary (instead of compiling it),
				which makes the CI job much faster \cite{pr_upload_binaries}.
			\item Added a new lint (trustfall query, test crates, tests)
				to detect tuple structs that changed to plain structs \cite{pr_lint_tuple_structs}.
			\item Added a new lint (trustfall query, test crates, tests) that checks whether a trait
				becomes or stops being unsafe \cite{pr_trait_unsafe} and added an \texttt{unsafe} type
				property to \texttt{Trait} in the schema and the adapter \cite{pr_unsafe_parameter_trait}.
			\item Added a \texttt{fields} edge to the \texttt{Variant} interface
				in the schema and the adapter \cite{pr_add_fields_variant_interface}.
		\end{itemize}

	\item Tomasz and Michał:
		\begin{itemize}
			\item Added a new lint (trustfall query, test crates, tests) to
				detect field removals from a struct variant in enums \cite{pr_new_lint_field_removals_struct_variant_enum}
				and added a field in the adapter for the lint \cite{pr_added_field_structvariant}.
			\item Added a new lint (trustfall query, test crates, tests) \cite{pr_add_function_parameters_semver_checks}
				to detect when function and method parameter count changes
				and added the retrieval of function parameter names in the adapter \cite{pr_add_function_parameters}.
			\item Fixed a bug where the rustdoc of the current and the baseline crates
				were overwriting each other \cite{pr_rustdoc_overwriting},
				which has been reported by a user \cite{issue_rustdoc_overwriting}.
		\end{itemize}

	\item Mieszko:
		\begin{itemize}
			\item Reported an incorrect behavior of the CLI which was choosing the latest release from the registry as
				a baseline version even when it had been yanked \cite{issue_choosing_baseline}. Introduced a fix and
				created a set of unit tests for choosing the baseline crate \cite{pr_choosing_baseline}.

			\item Reported a problem in release \texttt{v0.18.2} where the CLI was not looking for the baseline in the
				registry as it was supposed to do \cite{issue_finding_registry_baseline}.

			\item Reported a bug where the precompiled tool crashed on Windows machines \cite{issue_fail_on_windows}.
				Added a CI job that checks for similar issues \cite{pr_fail_on_windows} \cite{pr_ci_windows_comment}.

			\item Developed a new version of \texttt{cargo-semver-checks-action} \cite{pr_action_v2}
				\cite{pr_action_inputs_issues}, which consisted of:
			\begin{itemize}
				\item creating a test repository \cite{repo_action_tests} and using it to add a CI workflow that tests
					the basic functionalities of the action \cite{pr_action_first_tests}, then further developing the
					CI tests to cover all options added in the new version,
				\item making use of \texttt{cargo-semver-checks} built-in baseline choosing logic, which fixed the
					user-reported issue \cite{issue_action_builtin_logic},
				\item adding support for running the action on Windows- and MacOs-based runners,
				\item introducing input \texttt{manifest-path}, as requested by a user
					\cite{issue_action_manifest_path},
				\item introducing input \texttt{verbose}, as requested by a user \cite{issue_action_verbose},
				\item using pre-build binaries to speed up the action, as requested by a user
					\cite{issue_action_binaries},
				% \item \textbf{TODO}: \textit{baseline caching, when I will finish it...},
				\item rewriting the documentation of the action.
			\end{itemize}

			% These two are not even worth mentioning...
			% https://github.com/obi1kenobi/cargo-semver-checks/issues/390
			% https://github.com/obi1kenobi/cargo-semver-checks-action/issues/24
		\end{itemize}

	\item Bartosz:
		\begin{itemize}
			% \item \emph{SCRIBE!} \\
			% This scribe was like no other, \\
			% His notes could make a person shudder, \\
			% Each word he wrote, a work of art, \\
			% A skill that set him far apart. \\

			% Meetings became a grand event, \\
			% When his pen and paper were present, \\
			% Colleagues vied for his attention, \\
			% To ensure their words got a mention. \\

			% For this scribe's notes were legendary, \\
			% Capturing every detail, quite extraordinary, \\
			% No meeting was complete without his touch, \\
			% A true master of the notetaking clutch. \\

			\item Added several new lints (trustfall queries, test crates, tests)
				to detect when different items have been marked with the \texttt{must\_use}
				attribute. Writing separate lints for individual items allowed to provide more
				detailed messages for the user, improved the code structure by creating smaller,
				more specialized files and made the final review process easier. The items that
				undergo those checks are:
				\begin{itemize}
					\item enums \cite{pr_lint_enum_must_use_added},
					\item structs \cite{pr_lint_struct_must_use_added},
					\item traits \cite{pr_lint_trait_must_use_added},
					\item functions \cite{pr_lint_function_must_use_added},
					\item methods \cite{pr_method_moved_to_trait_must_use_added},
					\item inherent methods (reported only when one was both moved to
						a public trait and marked with the attribute)
						\cite{pr_inherent_method_must_use_added}.
				\end{itemize}

			% Not closed yet:
			% https://github.com/obi1kenobi/cargo-semver-checks/issues/217
			% https://github.com/obi1kenobi/cargo-semver-checks/issues/292
			% https://github.com/obi1kenobi/cargo-semver-checks/issues/294

\end{itemize}

	\item Mieszko and Bartosz:
		\begin{itemize}
			\item Added a new lint (trustfall query, test crates, tests) to detect when an exhaustive
				public enum has the \texttt{non\_exhaustive} attribute added \cite{pr_lint_enum_non_exhaustive}.

			\item Designed and implemented a new adapter schema for handling attributes
				\cite{pr_adapter_new_schema_for_attributes}.
				Updated all lints that check attributes to use the new schema, as well as added multiple
				new test cases to the queries \cite{pr_new_schema_for_attributes}.
		\end{itemize}
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             Conclusion              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}\label{r:chapter_conclusion}

TODO:
\begin{itemize}
	\item write a conclusion
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%            Bibliography             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix

\begin{thebibliography}{99}\label{r:chapter_bibliography}
\addcontentsline{toc}{chapter}{Bibliography}

% \bibitem[Bea65]{beaman} Juliusz Beaman, \textit{Morbidity of the Jolly
%     function}, Mathematica Absurdica, 117 (1965) 338--9.
\bibitem{issue_merge_cargo} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/issues/61
\bibitem{issue_cli_interface} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/issues/86
\bibitem{issue_compiling_fails} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/issues/317
\bibitem{issue_libp2p} TODO \\ https://github.com/libp2p/rust-libp2p/pull/3312
\bibitem{pr_added_field_structvariant} TODO \\ https://github.com/obi1kenobi/trustfall-rustdoc-adapter/pull/3
\bibitem{pr_new_lint_field_removals_struct_variant_enum} TODO \\ https://github.com/obi1kenobi/trustfall-rustdoc-adapter/pull/3
\bibitem{issue_wrong_path_manifest_path} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/issues/174
\bibitem{pr_add_function_parameters} TODO \\ https://github.com/obi1kenobi/trustfall-rustdoc-adapter/pull/4
\bibitem{pr_changed_how_manifest_baseline_built} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/173
\bibitem{issue_baseline_rustdoc_from_registry_default_features} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/issues/147
\bibitem{pr_add_running_on_rust_libp2p} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/180
\bibitem{pr_add_function_parameters_semver_checks} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/170
\bibitem{issue_tests_fail_on_nightly} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/issues/175
\bibitem{pr_tests_fail_on_nightly} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/184
\bibitem{pr_add_error_template_instantiation} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/189
\bibitem{pr_test_specifying_package_name} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/192
\bibitem{pr_renamed_directories} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/195
\bibitem{pr_renamed_directories_2} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/205
\bibitem{pr_renamed_directories_3} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/216
\bibitem{pr_one_macro} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/204
\bibitem{pr_split_each_test} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/203
\bibitem{pr_upload_binaries} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/208
\bibitem{pr_run_lints_nonchanged_crates} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/208
\bibitem{pr_clippy_lint} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/244
\bibitem{pr_bugfix_printed_baseline} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/248
\bibitem{pr_run_cargo_build} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/246
\bibitem{pr_lint_tuple_structs} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/249
\bibitem{pr_unsafe_parameter_trait} TODO \\ https://github.com/obi1kenobi/trustfall-rustdoc-adapter/pull/19
\bibitem{pr_rustdoc_trait_incompatibility} TODO \\ https://github.com/obi1kenobi/trustfall-rustdoc-adapter/pull/24
\bibitem{issue_tests_fail_unknown} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/issues/243
\bibitem{issue_strengthen_back} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/issues/256
\bibitem{pr_trait_unsafe} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/252
\bibitem{pr_add_fields_variant_interface} TODO \\ https://github.com/obi1kenobi/trustfall-rustdoc-adapter/pull/25
\bibitem{issue_help_messages} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/issues/172
\bibitem{issue_bevy_audio} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/issues/274
\bibitem{issue_duplicated_failure} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/issues/277
\bibitem{pr_rustdoc_overwriting} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/270
\bibitem{issue_rustdoc_overwriting} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/issues/309
\bibitem{pr_openssl} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/324
\bibitem{issue_openssl} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/issues/272
\bibitem{issue_apple_bitflags} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/issues/167
\bibitem{pr_placeholder_1} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/340
\bibitem{pr_placeholder_2} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/341
\bibitem{pr_placeholder_3} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/347
\bibitem{pr_placeholder_4} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/348
\bibitem{pr_placeholder_5} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/350
\bibitem{pr_placeholder_6} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/issues/351
\bibitem{issue_fails_yanked} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/issues/275
\bibitem{issue_internal_data} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/issues/342
\bibitem{pr_exit_code} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/344
\bibitem{pr_ci_rustdoc} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/352
\bibitem{pr_broken_link} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/358
\bibitem{issue_reexporting} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/issues/343
\bibitem{pr_false_positive_target_specific} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/375
\bibitem{issue_color_always} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/issues/326
\bibitem{pr_color_always} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/360
\bibitem{pr_library} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/314
\bibitem{pr_lint_enum_non_exhaustive} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/155
\bibitem{pr_new_schema_for_attributes} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/171
\bibitem{pr_adapter_new_schema_for_attributes} TODO \\ https://github.com/obi1kenobi/trustfall-rustdoc-adapter/pull/5

\bibitem{pr_action_first_tests} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks-action/pull/19
\bibitem{issue_choosing_baseline} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/issues/254
\bibitem{pr_choosing_baseline} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/255
\bibitem{pr_action_inputs_readme} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks-action/pull/20
\bibitem{issue_finding_registry_baseline} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/issues/382
\bibitem{issue_fail_on_windows} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/issues/276
\bibitem{pr_fail_on_windows} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/389
\bibitem{pr_ci_windows_comment} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/407
\bibitem{pr_action_v2} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks-action/pull/21
\bibitem{pr_action_inputs_issues} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks-action/pull/25
\bibitem{repo_action_tests} TODO \\
https://github.com/mgr0dzicki/cargo-semver-action-ref-slice
\bibitem{issue_action_builtin_logic} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks-action/issues/23
\bibitem{issue_action_manifest_path} TODO \\
https://github.com/obi1kenobi/cargo-semver-checks-action/issues/18
\bibitem{issue_action_verbose} TODO \\
https://github.com/obi1kenobi/cargo-semver-checks-action/issues/16
\bibitem{issue_action_binaries} TODO \\
https://github.com/obi1kenobi/cargo-semver-checks-action/issues/8

\bibitem{pr_lint_struct_must_use_added} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/279
\bibitem{pr_lint_trait_must_use_added} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/280
\bibitem{pr_lint_function_must_use_added} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/281
\bibitem{pr_lint_enum_must_use_added} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/278
\bibitem{pr_inherent_method_must_use_added} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/283
\bibitem{pr_method_moved_to_trait_must_use_added} TODO \\ https://github.com/obi1kenobi/cargo-semver-checks/pull/282

\bibitem{Rust-1} Rust Team,
	\textit{Rust Programming Language} (2023) \\
	https://www.rust-lang.org/

\bibitem{Rust-2} Wikipedia,
	\textit{Rust (programming language)} (2023) \\
	https://en.wikipedia.org/wiki/Rust\_(programming\_language)/

\bibitem{survey} Stack Overflow,
	\textit{Annual Developer Survey} (2022) \\
	https://insights.stackoverflow.com/survey/

\bibitem{Rust-for-Linux} Wikipedia,
	\textit{Rust for Linux} (2023) \\
	https://en.wikipedia.org/wiki/Rust\_for\_Linux/

\bibitem{Cargo} Rust Team,
	\textit{The Cargo Book} (2023) \\
	https://doc.rust-lang.org/cargo/index.html/

\bibitem{Cargo-vs-pip} William Manley,
	\textit{Pip and Cargo are not the same} (2022) \\
	https://doc.rust-lang.org/cargo/index.html/

\bibitem{Abstract-Syntax-Tree} Wikipedia,
	\textit{Abstract syntax tree} (2023) \\
	https://en.wikipedia.org/wiki/Abstract\_syntax\_tree/

\bibitem{Semantic-Versioning} semver.org,
	\textit{Semantic Versioning 2.0.0} (2022) \\
	https://semver.org/

\bibitem{paper} Hao Li, Filpe R Cogo, Cor-Paul Bezemer, \\
    \textit{An Empirical Study of Yanked Releases in the Rust Package Registry}
    (2022) \\ https://arxiv.org/pdf/2201.11821.pdf

\bibitem{fearless-cargo-update} Predrag Gruevski,
    \textit{Towards fearless cargo update} (2022) \\
    https://predr.ag/blog/toward-fearless-cargo-update/

\bibitem{elm-lang} Evan Czaplicki,
    \textit{Elm Programming Language} (2021) \\
    https://elm-lang.org/

\bibitem{pyo3-issue}
    \textit{Github PyO3 issue \#285} (2018) \\
    https://github.com/PyO3/pyo3/issues/285

\bibitem{clap-issue}
    \textit{Github clap issue \#3876} (2022) \\
    https://github.com/clap-rs/clap/issues/3876

\bibitem{block-buffer-issue}
    \textit{Github RustCrypto issue \#22} \\
    https://github.com/RustCrypto/utils/issues/22

\end{thebibliography}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             Attachments             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter*{Attachments}\label{r:chapter_attachments}
\addcontentsline{toc}{chapter}{Attachments}

\section*{Source code structure}

<Here describe the project structure of the included CD>


\section*{Tests}

<Here describe the tests (and possibly how to run them) of the included CD>

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-2
%%% End:
