\documentclass[licencjacka,en]{pracamgr}

\autor{Tomasz Nowak}{429575}
\autori{Michał Staniewski}{429598}
\autorii{Mieszko Grodzicki}{429132}
\autoriii{Bartosz Smolarczyk}{429594}
\opiekun{mgr Michał Możdżonek\\
  Institute of Informatics\\
  }
\date{May 2023}
\kierunek{Computer Science}
% Wg klasyfikacji Socrates-Erasmus:
\dziedzina{
11.3 Computer Science\\
}
% Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
\klasyfikacja{
  D. Software\\
  D.2. Software Engineering\\
  D.2.4. Software/Program Verification
  }

\title{Accelerating package expansion in Rust through development of a semantic versioning tool}
\titlepl{Przyspieszenie rozwoju pakietów w języku Rust poprzez rozbudowę narzędzia do semantycznego wersjonowania}
\keywords{Rust, semantic versioning, continuous integration, package manager}

\begin{document}
\maketitle

\begin{abstract}
In many programming languages there exist countless nuances,
making developers accidentally release new versions of their packages
that are not backwards-compatible.
Such releases can directly impact projects which are using their packages,
causing bugs or even compilation errors when using the latest version.
One of the affected languages is Rust,
which also lacks (itself) a built-in mechanism for enforcing semantic versioning.

The aim of this thesis is to describe the development of a tool
for Rust programmers to reduce the chances of publishing
a new version of the code that violates semantic versioning.

There are already on-going plans to bundle this tool
into the language's standard development toolchain.
It would make it commonly used and therefore help users to safely get bug fixes,
security patches and new functionality,
without worrying about their app being broken by a dependency change.
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftables



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%            Introduction             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

Rust is a relatively new language that has lately been gaining on popularity.
Amongst its standard development toolchain there is a software called cargo
-- Rust's build system and package manager,
which handles building a crate -- a package with Rust code.
One of cargo's responsibilities is to search for the newest crate versions,
download them and build dependencies
(that is, other libraries / crates that the code uses).

Cargo assumes that all crates follow semantic versioning
-- a set of rules that decide when it is safe to use the new version of a library
without any problems (the projects that depend on this library must still compile).
Thanks to that, developers of libraries can release patches and bugfixes
and cargo by default will automatically use those newest releases.
The exact definition of semantic versioning is explained in chapter \ref{r:chapter_definitions}.

It turns out that it is not obvious which changes are backwards-compatible
and which are not. There are numerous examples (listed in \ref{r:section_usageofsemver})
where experienced Rust developers made a mistake
(due to insufficient knowledge about the language or by overlooking something)
that changed the public API of a library in such a way that users' code stopped compiling.

The authors of this thesis present their work on a tool that detects and notifies about
a subset of problems that make Rust libraries' public API non-backwards compatible,
with the goal to make problems with semantic versioning less frequent in the Rust community.
The exact goals of this project are described in chapter \ref{r:chapter_vision}.

The project is open-source -- all of the authors' work is visible in public repositories
(listed in \ref{r:section_projectstructure}). The project existed before their contributions,
thus chapter \ref{r:chapter_implementation} mainly describes how they have
extended the project's functionalities and fixed its issues.
Chapter \ref{r:chapter_summary} is a summary of their results and the project's impact
on the Rust community.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             Definitions             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Definitions}\label{r:chapter_definitions}

\section{Rust language}

Rust is a language (...)


\section{cargo}

Cargo is the Rust package manager, which (...)

Cargo requires the packages (called crates) to follow semantic versioning (semver).

The place where cargo (...) is called the registry.
Its web version is available at crates.io.


\section{Semantic versioning (semver)}

Semver is (...)

There are three types of release:
\begin{itemize}
	\item patch -- (...)
	\item minor -- (...)
	\item major -- (...)
\end{itemize}

Each release is marked with a number (...)

For example, (...)

By default, cargo uses (...)

Cargo supports yanking releases from the registry.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%          State of the art           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{State of the art}\label{r:chapter_stateoftheart}

\section{Usage of semver in Rust}\label{r:section_usageofsemver}

<Above we explained what semver is, now explain in general what are the common difficulties and problems>

<Why is it easy to break semver?>

<Why people tend to break semver?>

\section{Consequences of breaking semver}

When a library maintainer breaks semver, for (...) reasons, the users' code stops compiling and (...)


\section{Real-life examples of semver breaks}

<Here write about cases our mentor mentioned in his blogs>

<Here also write about cases users reported in the github issue>

<Here mention the paper describing that 43\% of yanked releases
are because of semver breaks and 3.7\% of all >300'000 releases are yanked>

<Here mention that we've developed (currently: we're developing)
a script that will scan all releases for the semver breaks
we can detect and the results are presented in chapter (...)>


\section{Existing tools for detecting semver breaks}

In some languages <list here examples>, it is easy to check for semver breaks.

In Rust there are three existing tools for (...)
\begin{itemize}
	\item cargo-breaking -- <here explain a bit how it works and why it is no longer maintained>
	\item rust-semverver -- <here explain a bit how it works and why it is no longer maintained>
	\item cargo-semver-checks -- <here explain a bit how it works and that it is maintained (e.g. by us) and it is our project>
\end{itemize}

In other popular languages, there haven't been as much progress, because (...)



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%               Vision                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Vision}\label{r:chapter_vision}

\section{Project purpose}

Cargo-semver-checks is designed to (...)

The goal is to (...)


\section{Project usage}

The main usages of the tool are:
\begin{itemize}
	\item running locally from the command-line before publishing, (...)
	\item running in continuous integration (e.g. GitHub Actions) to check PRs, (...)
\end{itemize}

<Here describe the vision on how the tool should be automatically run in continuous integration
and how that will benefit the Rust developers>

\subsection{Running in continuous integration}

<Here describe the vision on how the tool should be automatically run in continuous integration
and how that will benefit the Rust developers>

\subsection{Plans to merge the tool into cargo}

<Here describe the existing plans to merge the project in which we're contributing
to the official Rust toolchain and how that will benefit the Rust developers>


\section{Project baseline}

Before our contributions, the project was in a (...) state
with (...) issues.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%               Theory                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Theory}\label{r:chapter_theory}

\section{Project structure}\label{r:section_projectstructure}

The tool heavily uses the rustdocs, (...).
It parses its JSON through Trustfall (...).

The project consists of three sub-projects:
\begin{enumerate}
	\item cargo-semver-checks -- a command line interface tool to run lints that are Trustfall queries, (...)
	\item trustfall-rustdoc -- allows running Trustfall queries over rustdoc in a version-agnostic manner, (...)
	\item trustfall-rustdoc-adapter -- implements the Trustfall interface for one specific rustdoc version, (...)
\end{enumerate}

<Possibly insert that diagram here?>


\section{cargo-semver-checks}

<Here describe the inner-workings of the command line interface tool>


\section{trustfall-rustdoc-adapter}

<Here describe the inner-workings of the adapters>



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%           Implementation            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Implementation}\label{r:chapter_implementation}

\section{New lints}

<Here write a list about the new lints we've written>


\section{Test suite}

<Here write a list about the improvements in the testing suite>


\section{Command line interface}

<Here write a list about changes that made the command line interface better>


\section{Bugfixes}

<Here write a list about found and fixed bugs>


\section{Continuous integration improvements}

<Here write a list about the V2 of the continuous integration>


\section{Script}

<Here write about the script that searches all existing releases for detected semver breaks>


\section{Healthier codebase}

<Here write a list of changes that made the codebase better>



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                Team                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Team}\label{r:chapter_team}

\section{Used methodology}

<Here describe how we've been developing the tool>


\section{Responsibilities}

<Here describe who did what>



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%               Summary               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Summary}\label{r:chapter_summary}

\section{Steady increase in tool's popularity}

<Here show how the number of downloads has changed>

<Here show how the number of stars on GitHub has changed>

<Here describe how our work might have impacted those results>

<Here show the comments of users on GitHub.
As one of the examples, give the maintainer of a big
library that created an issue ,,Make continuous integration runs faster''
and after learning about one of our PRs to make the continuous integration faster,
he was so excited that he wrote a comment with a tip in our PR>

<Here list the maintainers of big libraries that started using the tool during our development>


\section{Script}

<Here show the results of the script that searches all existing releases for detected semver breaks>

(to consider: maybe move it to an appendix?)

<Here describe how our new lints can make an impact on the community based on the found semver breaks from the script>


\section{Future-proofing}

<Here describe other overall changes that prepares the tool to be more successful in the future>



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%            Bibliography             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix

\begin{thebibliography}{99}\label{r:chapter_bibliography}
\addcontentsline{toc}{chapter}{Bibliography}

% \bibitem[Bea65]{beaman} Juliusz Beaman, \textit{Morbidity of the Jolly
%     function}, Mathematica Absurdica, 117 (1965) 338--9.

\end{thebibliography}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             Attachments             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter*{Attachments}\label{r:chapter_attachments}
\addcontentsline{toc}{chapter}{Attachments}

\section*{Source code structure}

<Here describe the project structure of the included CD>


\section*{Tests}

<Here describe the tests (and possibly how to run them) of the included CD>

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-2
%%% End:
