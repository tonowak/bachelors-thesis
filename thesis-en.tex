\documentclass[licencjacka,en]{pracamgr}

\autor{Tomasz Nowak}{429575}
\autori{Michał Staniewski}{429598}
\autorii{Mieszko Grodzicki}{429132}
\autoriii{Bartosz Smolarczyk}{429594}
\opiekun{mgr Michał Możdżonek\\
  Institute of Informatics\\
  }
\date{May 2023}
\kierunek{Computer Science}
% Wg klasyfikacji Socrates-Erasmus:
\dziedzina{
11.3 Computer Science\\
}
% Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
\klasyfikacja{
  D. Software\\
  D.2. Software Engineering\\
  D.2.4. Software/Program Verification
  }

\title{Accelerating package expansion in Rust through development of a semantic versioning tool}
\titlepl{Przyspieszenie rozwoju pakietów w języku Rust poprzez rozbudowę narzędzia do semantycznego wersjonowania}
\keywords{Rust, semantic versioning, continuous integration, package manager}

\begin{document}
\maketitle

\begin{abstract}
In many programming languages there exist countless nuances,
making developers accidentally release new versions of their packages
that are not backwards-compatible.
Such releases can directly impact projects which are using their packages,
causing bugs or even compilation errors when using the latest version.
One of the affected languages is Rust,
which also lacks (itself) a built-in mechanism for enforcing semantic versioning.

The aim of this thesis is to describe the development of a tool
for Rust programmers to reduce the chances of publishing
a new version of the code that violates semantic versioning.

There are already on-going plans to bundle this tool
into the language's standard development toolchain.
It would make it commonly used and therefore help users to safely get bug fixes,
security patches and new functionality,
without worrying about their app being broken by a dependency change.
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftables

\chapter*{Executive summary}
\addcontentsline{toc}{chapter}{Executive summary}

TODO:
\begin{itemize}
	\item write the executive summary (around one page long)
	\item describe in short what is the goal of the project and what it solves
	\item describe that the project is indeed needed
	\item mention what we've done and how it moved the project towards the vision
	\item mention the results and the impact on the community
\end{itemize}

\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

Rust is a relatively new language that has lately been gaining on popularity.
Amongst its standard development toolchain there is a software called cargo
-- Rust's build system and package manager,
which handles building a crate -- a package with Rust code.
One of cargo's responsibilities is to search for the newest crate versions,
download them and build dependencies
(that is, other libraries / crates that the code uses).

Cargo assumes that all crates follow semantic versioning
-- a set of rules that decide when it is safe to use the new version of a library
without any problems (the projects that depend on this library must still compile).
Thanks to that, developers of libraries can release patches and bugfixes
and cargo by default will automatically use those newest releases.
The exact definition of semantic versioning is explained in chapter \ref{r:chapter_definitions}.

It turns out that it is not obvious which changes are backwards-compatible
and which are not. There are numerous examples (listed in \ref{r:section_usageofsemver})
where experienced Rust developers made a mistake
(due to insufficient knowledge about the language or by overlooking something)
that changed the public API of a library in such a way that users' code stopped compiling.

The authors of this thesis present their work on a tool that detects and notifies about
a subset of problems that make Rust libraries' public API non-backwards compatible,
with the goal to make problems with semantic versioning less frequent in the Rust community.
The exact goals of this project are described in chapter \ref{r:chapter_vision}.

The project is open-source -- all of the authors' work is visible in public repositories
(listed in \ref{r:section_projectstructure}). The project existed before their contributions,
thus chapter \ref{r:chapter_implementation} mainly describes how they have
extended the project's functionalities and fixed its issues.
Chapter \ref{r:chapter_evaluation} is a summary of their results and the project's impact
on the Rust community.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             Definitions             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Definitions}\label{r:chapter_definitions}

\section{Rust language}

With its first stable release in 2015, Rust is a relatively new programming language that
puts a strong emphasis on type-safety, memory-safety, performance and concurrency. Unlike
other memory-safe languages, Rust does not use reference counting nor a garbage collector.
Instead it tracks the object lifetime of all the program's references during compilation,
using its built-in mechanism named ''borrow checker''.

Among many benefits and advantages of using Rust there are three dominant features. Firstly,
it provides the user with great performance, both time- and memory-wise, allowing for
writing efficient applications. Secondly, it is reliable -- with extensive type system and
focus on runtime safety, Rust prevents the user from making multiple bugs
already during compilation. Finally, it boosts productivity -- its documentation is
comprehensive and the compiler's error messages are clear and helpful. Rust also provides
an easy to use, integrated package manager (named cargo), a dedicated build tool,
an auto-formatter and many more.

According to surveys conducted amongst developers, Rust is considered to be the most enjoyable
programming language for the 7th year in a row (as of 2022 summary, meaning it was always on top
since its release in 2015). Over 87\% of respondents who have previously used Rust would
like to continue programming in it.

Because of the high level of safety it provides, Rust has also become the secondary
language for writing the Linux kernel (with the primary being C). While there have been
attempts to add other languages (f.e. C++ in 1997), Rust is the first one to successfully
make it since the kernel's first release in 1991.

\section{Rust's package manager and build system -- cargo}

Cargo is the official package manager for Rust. It is responsible for compiling the user's
packages, downloading their dependencies and uploading them to the selected package registry.
It is important to note that in Rust, packages are often refered to as \texttt{crates} with both names
being equivalent and commonly used.

One can think of cargo as the Rust analogue of Python's pip. But despite their similar roles,
cargo has many advantages making it a lot safer than pip:
\begin{itemize}
	\item Cargo's crates are always installed using venvs (virtual environments), thus they cannot be
		installed in a location that would interfere with unrelated code.
	\item When user adds a crate to their project, they can only use its interface and there is
		no possibility of accessing eventual dependencies installed with it.
	\item The crate's name must also be included in a special file named \texttt{Cargo.toml}, not
		just in the source code file.
	\item To make the package's public interface explicit, Rust provides a series of tools for
		privacy management. Because of this, it is much more difficult for the user to make their
		project dependent on something that the package's author did not intend to offer and could
		make private in future versions, causing a difficult to detect break on the user's end.
	\item Compatibility is taken seriously in Rust, thus packages' APIs are expected to be
		backwards-compatible (and to follow semantic versioning, described in another section) when
		a new version is released. When a package does not satisfy this requirement, there exists
		a procedure called \textit{yanking}. It allows to remove the faulty version from the index
		without deleting any data, but moves the index back to the most recent working version.
		Yet in case an incompatible package is downloaded before being yanked, projects using the
		package still mostly break during compilation or build time rather than runtime.
	\item The packages are also written in Rust and never require anything to work other than the
		package code itself. This minimizes the threat of missing pre-installed
		system dependencies.
	\item Cargo allows for an executable to contain different versions of the same package,
		enabling the user to include multiple dependencies based on a shared sub-dependency.
		When multiple versions of the sub-dependency are required, they are all included
		without conflicts.
\end{itemize}

Each package in Rust contains a special \texttt{Cargo.toml} file, called \textit{manifest}. It is
written in the TOML format for simplicity and contains all the metadata necessary for the package
to compile. Every manifest has numerous sections, with the most important two being:
\begin{itemize}
	\item \texttt{[package]} -- contains the information for cargo to compile the package.
		The minimum that must be provided are the package's name and version. Additional fields
		may be required when the maintainer wants to share their work with others by publishing
		to a registry.
	\item \texttt{[dependencies]} -- lists all of the package's dependencies. Before compiling,
		cargo has to search for and download all of them. The default search location is crates.io.
		In this case, the minimum required for each dependency are its name and version.
\end{itemize}
Presence of the manifest file allows the crates.io registry to display useful information about
a particular package. The users are provided with a \texttt{README.md} file, instructions on how to add
the package to their own Cargo.toml file, a list of all available versions, statistics regarding
the downloads for each version and more.

There also exists a second file for cargo -- \texttt{Cargo.lock}. It contains detailed
information about the used dependencies. Since all dependencies come from some version control
system, the user may not need to provide an exact revision of a dependency in their
\texttt{Cargo.toml} file. In this case, there are two scenarios for what happens with the
\texttt{Cargo.lock} file during compilation:
\begin{itemize}
	\item \texttt{Cargo.lock} is \textit{not} present -- cargo then creates it and for each
		dependency in the manifest downloads the most recent revision available, saving additional
		data about it in the file.
	\item \texttt{Cargo.lock} is present -- for the dependencies already present in the file, cargo
		does not look for their newest version and instead downloads the one specified in the file.
		For dependencies that are not present, it does the same as above except it adds them to
		the file rather than overwrites it.
\end{itemize}
There is a dedicated command for updating the dependencies -- \texttt{cargo update}.
Upon execution, the \texttt{Cargo.lock} file is either created or updated with the latest
revisions of used dependencies.

Besides downloading dependencies, users can also publish their own packages using
the \texttt{cargo publish} command. To use the command, the user must first authenticate with
an API token. After doing so, the command first performs preliminary checks, including searching
the manifest for a key to determine whether the user is allowed to upload their package
to the selected registry (by default crates.io). Once the checks are passed, all of the source code
from the current directory is compressed into a single \texttt{.crate} that is then uploaded
to the registry.

\section{Semantic versioning (semver)}

Semantic versioning is a set of rules and requirements dictating how version numbers for packages
are assigned and incremented. They are based on, but not limited, to currently widely used
practices in both open-source and closed software development. For these rules to work, one has to
first declare a clear and precise public API, changes of which refer to specific incrementations of
the package version number. The number is most often denoted as X.Y.Z (Major.Minor.Patch), where:
\begin{itemize}
	\item \textbf{Major} number is incremented when backwards-incompatible API changes were made,
	\item \textbf{Minor} number is incremented when a functionality was added in
		a backwards-compatible manner,
	\item \textbf{Patch} number is incremented when backwards-compatible bugfixes were made.
\end{itemize}
With these rules, version numbers and their changes reflect actions in the underlying
package's code. By definition, two versions are considered compatible if their leftmost non-zero
component remains unchanged.

The main purpose of semantic versioning is to make releasing new package versions easier.
When systems with multiple dependencies are considered, the lack of semver can have serious
consequences. If the dependency rules are too tight, one is in danger of facing a version lock
(inability to release a new version of one package without new versions of all packages depending
on it). On the other hand, if the rules are too loose, there is a risk of version promiscuity
(assuring that currently released version will be compatible with too many future releases).
Without semver, such issues can occur and make it difficult for developers to further expand
their projects.

In Rust, semver is used by cargo for specifying package version numbers. This makes for a common
compatibility convention between different versions of the same package. Cargo assumes that
it is safe to update a dependency within a compatibility range without it breaking the build.
This range can be defined in the manifest using the \textit{version requirement syntax}, allowing
the user to select the upper bound for maximum compatible number anywhere from one, specific
version (not allowing any updates), to no limit at all (equivalent to allowing even major updates).
The default behaviour is to update until the next major version.

When updating, if multiple packages share a dependency, cargo's resolver attempts to ensure
that they use as few versions of it as possible (ideally all packages may share a dependency
version), while ensuring none of them is forced to use a version outside of their compatibility
range. At the same time, the resolver tries to use the greatest version currently available within
that range. However, the resolver does not allow to use multiple versions of a package within the
same compatibility range and returns an error. For example, it is not possible to use two versions
of a package with the same Major and different Minor numbers, because they both are compatible
within the Major range by semver definition.

There also exists a procedure for packages that are not backwards-compatible despite their version
number suggesting compatibility, called \textit{yanking}. A yanked release is created when
a regular one is marked by users, stating that it should not be used. The package is not deleted
as it may be in use by some projects, but forces a version increment against its own number
whenever the next version is released. The resolver ignores yanked package versions unless they are
already present in the \texttt{Cargo.lock} file. While there are many reasons behind packages being
yanked, one of the main causes remains breaking semver.

\section{Abstract syntax tree (AST)}

An abstract syntax tree represents the abstract syntactic structure of the text (often source code)
in form of a tree, where every node denotes an occurence of some construct in it. The tree is
called "abstract" because it omits some syntax details, such as parantheses or if statements,
and focuses on structural or contextual details.

In most of the well-established programming languages semver validation is incredibly difficult
or even close to impossible. This is caused by the general lack of attention to semver during
their design processes. One of the possible approaches to cope with these difficulties is to try
detecting semver violations by looking at the abstract syntax tree of a language. Such tree of
a particular language might be changed along with its development, what makes maintenance of this
solution very time-consuming. Moreover, the work itself is pretty tedious and conceptually
challenging since to check for semver violations one needs to work on the two trees at a time.
To make matters worse, the tree sometimes changes without violating semver.

However, in some of the languages the problem becomes easier to handle. The Elm language was
created with semver validation in mind, and its package manager enforces semver on the users.
In the Rust language, there are some features that make semver validation easier. For example,
there are crates that expose the language's abstract syntax tree. There is also a feature called
\textit{rustdoc}, which exports all of the crate's public API into an accessible form (both human-
and machine-readable). Thanks to these, the semver validation problem seems particularily managable
in Rust, and there are some attempts addressing the issue already (mentioned in chapter
\ref{r:chapter_stateoftheart}).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%          State of the art           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{State of the art}\label{r:chapter_stateoftheart}

\section{Problems with using semver in Rust}\label{r:section_usageofsemver}

TODO:
\begin{itemize}
	\item explain why it is easy to break semver in Rust.
		Do that by giving specific, non-obvious code examples.
	\item search for sources from which to get examples
	\item explain other reasons as to why people tend to break semver
	\item don't give yet real-life examples (those will be in the sections under),
		write in a general way
	\item make it clear that using semver in Rust is hard
\end{itemize}

\section{Consequences of breaking semver}

TODO:
\begin{itemize}
	\item describe that breaking semver means that people's code stops compiling
	\item describe the possible scale of catastrophes
	\item don't give yet real-life examples, write in a general way
\end{itemize}

\section{Real-life examples of semver breaks}

TODO:
\begin{itemize}
	\item write (and cite) about cases our mentor mentioned in his blogs
	\item write about cases users reported in the github issue
	\item mention the paper describing that 43\% of yanked releases
		are because of semver breaks and 3.7\% of all >300'000 releases are yanked
	\item mention that we've developed
		a script that scans all releases for the semver breaks
		we can detect and the results are presented in some chapter
\end{itemize}

\section{Existing tools for detecting semver breaks}

TODO:
\begin{itemize}
	\item list languages which have semver checking built-in,
		explain that the language semantics were made for e.g. semver checking,
	\item list current tools for detecting semver breaks in Rust:
		cargo-breaking, rust-semverver, cargo-semver-checks
	\item for the first two, explain a bit how they work and why they are no longer maintained.
		Mieszko's slides have some info about that.
	\item for cargo-semver-checks, explain a bit how it works (rustdoc, json, etc.)
		and that contrary to the other two, it is maintained and it's made to be easily maintained.
		Mention that this is the project we're working on.
	\item research the current state of semver detection in other languages,
		explain that it's hard to do in popular languages,
		especially without features like rustdoc.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%               Vision                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Vision}\label{r:chapter_vision}

\section{Project purpose}

TODO:
\begin{itemize}
	\item explain for what the tool is designed for.
	\item explain its goals.
\end{itemize}

\section{Plans to merge the tool into cargo}

TODO:
\begin{itemize}
	\item mention why this project was chosen to be merged into cargo
	\item mention how that changed the project
	\item mention the progress with merging
	\item explain that it will happen with high probability
\end{itemize}

\section{Project usage}

TODO:
\begin{itemize}
	\item list two usages of the tool: running it locally and from CI
	\item explain them briefly
\end{itemize}

\subsection{Running locally}

TODO:
\begin{itemize}
	\item explain why someone would want to run it locally, mention \texttt{cargo publish}
	\item explain what options the user needs to run it locally (different ways to get rustdoc)
\end{itemize}

\subsection{Running in continuous integration}

TODO:
\begin{itemize}
	\item define PRs and GitHub
	\item describe the vision on how the tool should be automatically run in continuous integration
		and how that will benefit the Rust developers
\end{itemize}

\section{Project baseline}

TODO:
\begin{itemize}
	\item explain the state of the project before our contributions
	\item explain the issues of the project before our contributions
	\item explain how much the project vision weren't done before us
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%               Theory                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Theory}\label{r:chapter_theory}

\section{Project structure}\label{r:section_projectstructure}

TODO:
\begin{itemize}
	\item explain that the tool heavily uses rustdocs
	\item explain that it parses rustdoc through Trustfall
	\item define Trustfall
	\item explain how the lints look like
	\item mention that the project is split into three sub-projects,
		in this order: cargo-semver-checks, trustfall-rustdoc-adapter, trustfall-rustdoc,
		cargo-semver-checks-action,
		and briefly define what they do (like in our docs)
\end{itemize}

\section{cargo-semver-checks}

TODO:
\begin{itemize}
	\item describe in detail what is the job of cargo-semver-checks, without the adapters
	\item describe its different usages and how they retrieve the necessary data
\end{itemize}

\section{trustfall-rustdoc-adapter}

TODO:
\begin{itemize}
	\item describe the purpose of the rustdoc adapter
	\item mention what a Trustfall must implmement and that the rustdoc adapter
	\item describe what the adapter does and how trustfall-rustdoc-adapter achieves that
\end{itemize}

\section{trustfall-adapter}

TODO:
\begin{itemize}
	\item describe the purpose of the adapter and what it does
\end{itemize}

\section{cargo-semver-checks-action}

TODO:
\begin{itemize}
	\item describe the purpose of this subproject and what it does
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%           Implementation            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Implementation}\label{r:chapter_implementation}

TODO:
\begin{itemize}
	\item change names to ,,why users care about this''
\end{itemize}

\section{New lints}

<Here write a list about the new lints we've written>

\section{Test suite}

<Here write a list about the improvements in the testing suite>

\section{Command line interface}

<Here write a list about changes that made the command line interface better>

\section{Bugfixes}

<Here write a list about found and fixed bugs>

\section{Continuous integration improvements}

<Here write a list about the V2 of the continuous integration>

\section{Script}

<Here write about the script that searches all existing releases for detected semver breaks>

\section{Healthier codebase}

<Here write a list of changes that made the codebase better>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             Evaluation              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation}\label{r:chapter_evaluation}

\section{Steady increase in tool's popularity}

TODO:
\begin{itemize}
	\item show how the number of downloads has changed
	\item show how the number of stars on GitHub has changed
	\item describe how our work might have impacted those results
	\item show the comments of users on GitHub.
		As one of the examples, give the maintainer of a big
		library that created an issue ,,Make continuous integration runs faster''
		and after learning about one of our PRs to make the continuous integration faster,
		he was so excited that he wrote a comment with a tip in our PR.
		Search also for other such examples in the PRs and issues.
	\item list the maintainers of big libraries that started using the tool during our development
\end{itemize}

\section{Script}

TODO:
\begin{itemize}
	\item show the results of the script that searches all existing releases for detected semver breaks
	\item describe how our new lints can make an impact on the community based on the found semver breaks from the script
\end{itemize}

\section{Future-proofing}

TODO:
\begin{itemize}
	\item describe other overall changes that prepares the tool to be more successful in the future
	\item describe how the code changed to be more welcoming for next contributors
\end{itemize}

\section{Conclusion}

TODO:
\begin{itemize}
	\item write a conclusion
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                Team                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Team}\label{r:chapter_team}

\section{Used methodology}

TODO:
\begin{itemize}
	\item describe how we've been developing the tool
	\item describe our mentor's reviews
	\item describe how initially we splitted our work and how we did it later
\end{itemize}

\section{Responsibilities}

TODO:
\begin{itemize}
	\item describe who did what
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%            Bibliography             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix

\begin{thebibliography}{99}\label{r:chapter_bibliography}
\addcontentsline{toc}{chapter}{Bibliography}

% \bibitem[Bea65]{beaman} Juliusz Beaman, \textit{Morbidity of the Jolly
%     function}, Mathematica Absurdica, 117 (1965) 338--9.

\bibitem[]{Rust-1} Rust Team,
	\textit{Rust Programming Language} (2023) \\
	https://www.rust-lang.org/

\bibitem[]{Rust-2} Wikipedia,
	\textit{Rust (programming language)} (2023) \\
	https://en.wikipedia.org/wiki/Rust\_(programming\_language)/

\bibitem[]{survey} Stack Overflow,
	\textit{Annual Developer Survey} (2022) \\
	https://insights.stackoverflow.com/survey/

\bibitem[]{Rust-for-Linux} Wikipedia,
	\textit{Rust for Linux} (2023) \\
	https://en.wikipedia.org/wiki/Rust\_for\_Linux/

\bibitem[]{Cargo} Rust Team,
	\textit{The Cargo Book} (2023) \\
	https://doc.rust-lang.org/cargo/index.html/

\bibitem[]{Cargo-vs-pip} William Manley,
	\textit{Pip and Cargo are not the same} (2022) \\
	https://doc.rust-lang.org/cargo/index.html/

\bibitem[]{Abstract-Syntax-Tree} Wikipedia,
	\textit{Abstract syntax tree} (2023) \\
	https://en.wikipedia.org/wiki/Abstract\_syntax\_tree/

\bibitem[]{Semantic-Versioning} semver.org,
	\textit{Semantic Versioning 2.0.0} (2022) \\
	https://semver.org/

\end{thebibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             Attachments             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter*{Attachments}\label{r:chapter_attachments}
\addcontentsline{toc}{chapter}{Attachments}

\section*{Source code structure}

<Here describe the project structure of the included CD>


\section*{Tests}

<Here describe the tests (and possibly how to run them) of the included CD>

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-2
%%% End:
