\documentclass[licencjacka,en]{pracamgr}
\usepackage{hyperref}

\autor{Tomasz Nowak}{429575}
\autori{Michał Staniewski}{429598}
\autorii{Mieszko Grodzicki}{429132}
\autoriii{Bartosz Smolarczyk}{429594}
\opiekun{mgr Michał Możdżonek\\
  Institute of Informatics\\
  }
\date{May 2023}
\kierunek{Computer Science}
% Wg klasyfikacji Socrates-Erasmus:
\dziedzina{
11.3 Computer Science\\
}
% Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
\klasyfikacja{
  D. Software\\
  D.2. Software Engineering\\
  D.2.4. Software/Program Verification
  }

\title{Accelerating package expansion in Rust through development of a semantic versioning tool}
\titlepl{Przyspieszenie rozwoju pakietów w języku Rust poprzez rozbudowę narzędzia do semantycznego wersjonowania}
\keywords{Rust, semantic versioning, continuous integration, package manager}

\begin{document}
\maketitle

\begin{abstract}
In many programming languages there exist countless nuances,
making developers accidentally release new versions of their packages
that are not backwards-compatible.
Such releases can directly impact projects which are using their packages,
causing bugs or even compilation errors when using the latest version.
One of the affected languages is Rust,
which also lacks (itself) a built-in mechanism for enforcing semantic versioning.

The aim of this thesis is to describe the development of a tool
for Rust programmers to reduce the chances of publishing
a new version of the code that violates semantic versioning.

There are already on-going plans to bundle this tool
into the language's standard development toolchain.
It would make it commonly used and therefore help users to safely get bug fixes,
security patches and new functionality,
without worrying about their app being broken by a dependency change.
\end{abstract}

% Abstrakt po polsku (potrzebny tylko w APD?)
% W wielu językach programowania istnieją liczne niuanse sprawiające, że deweloperzy
% omyłkowo publikują nowe wersje swoich pakietów bez zachowania kompatybilności wstecznej.
% Takie sytuacje mogą bezpośrednio wpłynąć na projekty korzystające z ich pakietów,
% powodując błędy bądź nawet uniemożliwiając kompilację po aktualizacji do najnowszej wersji.
% Jednym z języków dotkniętych tym problemem jest Rust, który nie posiada wbudowanego
% mechanizmu wymuszającego semantyczne wersjonowanie.

% Celem tej pracy jest przedstawienie rozwoju narzędzia dla języka Rust, które
% zmniejsza ryzyko publikacji kodu nieprzestrzegającego zasad semantycznego wersjonowania.

% Są również plany, aby narzędzie to stało się częścią standardowego toolchainu
% deweloperskiego. Skutkowałoby to jego powszechnym użyciem i tym samym zagwarantowałoby
% użytkownikom, że korzystanie z poprawek błędów, łatek bezpieczeństwa oraz nowych
% funkcjonalności pakietów nie doprowadzi do awarii ich aplikacji.

\tableofcontents
%\listoffigures
%\listoftables

\chapter*{Executive summary}
\addcontentsline{toc}{chapter}{Executive summary}

TODO:
\begin{itemize}
	\item write the executive summary (around one page long)
	\item describe in short what is the goal of the project and what it solves
	\item describe that the project is indeed needed
	\item mention what we've done and how it moved the project towards the vision
	\item mention the results and the impact on the community
\end{itemize}

\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

Rust is a relatively new language that has lately been gaining on popularity.
Amongst its standard development toolchain there is a software called cargo
-- Rust's build system and package manager,
which handles building a crate -- a package with Rust code.
One of cargo's responsibilities is to search for the newest crate versions,
download them and build dependencies
(that is, other libraries / crates that the code uses).

Cargo assumes that all crates follow semantic versioning
-- a set of rules that decide when it is safe to use the new version of a library
without any problems (the projects that depend on this library must still compile).
Thanks to that, developers of libraries can release patches and bugfixes
and cargo by default will automatically use those newest releases.
The exact definition of semantic versioning is explained in chapter \ref{r:chapter_definitions}.

It turns out that it is not obvious which changes are backwards-compatible
and which are not. There are numerous examples (listed in \ref{r:section_usageofsemver})
where experienced Rust developers made a mistake
(due to insufficient knowledge about the language or by overlooking something)
that changed the public API of a library in such a way that users' code stopped compiling.

The authors of this thesis present their work on a tool that detects and notifies about
a subset of problems that make Rust libraries' public API non-backwards compatible,
with the goal to make problems with semantic versioning less frequent in the Rust community.
The exact goals of this project are described in chapter \ref{r:chapter_vision}.

The project is open-source -- all of the authors' work is visible in public repositories
(listed in \ref{r:section_projectstructure}). The project existed before their contributions,
thus chapter \ref{r:chapter_implementation} mainly describes how they have
extended the project's functionalities and fixed its issues.
Chapter \ref{r:chapter_evaluation} is a summary of their results and the project's impact
on the Rust community.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             Definitions             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Definitions}\label{r:chapter_definitions}

\section{Rust language}

TODO:
\begin{itemize}
	\item describe Rust
	\item mention its main selling points, wikipedia might be helpful
		(though write the description yourself, without copy-pasting),
		alternatively search for more informal Rust descriptions
	\item mention its popularity (stackoverflow surveys, linux kernel, etc)
\end{itemize}

\section{Rust's package manager and build system -- cargo}

TODO:
\begin{itemize}
	\item describe cargo
	\item compare it to Python's pip -- a lot of people know what it is
	\item mention differences with pip -- e.g. yanking releases
	\item mention that it follows semver and it is described in another section
	\item define Manifest file
	\item describe what happens during cargo update
	\item define the registry and mention its site -- crates.io
	\item describe how publishing packages work (e.g. how the CLI for it works)
\end{itemize}

\section{Semantic versioning (semver)}

TODO:
\begin{itemize}
	\item define semantic versioning, semver.org might be useful
	\item describe why it is used
	\item describe what happens during cargo update
	\item exactly define how semver works in Rust
	\item mention how yanking releases is useful for semver
	\item mention that it is not clearly defined in Rust what is patch, minor and major,
		use the comments from Predrag's tweets about patch vs minor https://twitter.com/PredragGruevski/status/1618684048389607424
		and Predrag's blog about breaking vs major https://predr.ag/blog/some-rust-breaking-changes-do-not-require-major-version/
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%          State of the art           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{State of the art}\label{r:chapter_stateoftheart}

\section{Problems with using semver in Rust}\label{r:section_usageofsemver}

TODO:
\begin{itemize}
	\item explain why it is easy to break semver in Rust.
		Do that by giving specific, non-obvious code examples.
	\item search for sources from which to get examples
	\item explain other reasons as to why people tend to break semver
	\item don't give yet real-life examples (those will be in the sections under),
		write in a general way
	\item make it clear that using semver in Rust is hard
\end{itemize}

\section{Consequences of breaking semver}

TODO:
\begin{itemize}
	\item describe that breaking semver means that people's code stops compiling
	\item describe the possible scale of catastrophes
	\item don't give yet real-life examples, write in a general way
\end{itemize}

\section{Real-life examples of semver breaks}

TODO:
\begin{itemize}
	\item write (and cite) about cases our mentor mentioned in his blogs
	\item write about cases users reported in the github issue
	\item mention the paper describing that 43\% of yanked releases
		are because of semver breaks and 3.7\% of all >300'000 releases are yanked
	\item mention that we've developed
		a script that scans all releases for the semver breaks
		we can detect and the results are presented in some chapter
\end{itemize}

\section{Existing tools for detecting semver breaks}\label{r:section_existing_semver_tools}

TODO:
\begin{itemize}
	\item list languages which have semver checking built-in,
		explain that the language semantics were made for e.g. semver checking,
	\item list current tools for detecting semver breaks in Rust:
		cargo-breaking, rust-semverver, cargo-semver-checks
	\item for the first two, explain a bit how they work and why they are no longer maintained.
		Mieszko's slides have some info about that.
	\item for cargo-semver-checks, explain a bit how it works (rustdoc, json, etc.)
		and that contrary to the other two, it is maintained and it's made to be easily maintained.
		Mention that this is the project we're working on.
	\item research the current state of semver detection in other languages,
		explain that it's hard to do in popular languages,
		especially without features like rustdoc.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%               Vision                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Vision}\label{r:chapter_vision}

\section{Project purpose}

We have taken part in the development of \texttt{cargo-semver-checks}
-- a tool meant to detect semver breaks of a Rust project before publishing
its new version to the registry.
The main goal of the project is to reduce the number of issues with new releases
of libraries, which would deepen the Rust community's trust
in the packages they are using and in the whole ecosystem.

The tool is \textit{not} meant to detect all possible semver breaks.
Instead, the detection mechanism and existing lints are written
with a strong focus on finding only true-positives.
Each false-positive (which is defined as a scenario where the tool
wrongly reports a semver break) is perceived as a bug in the tool.
There are two advantages with this approach:
\begin{itemize}
	\item the tool is suited to be used in continuous integration
		for finding semver issues in commits or Pull Requests
		-- it reports semver breaks only when
		its output should not be ignored and requires manual inspection,
	\item we're avoiding a scenario in which
		a user encounters false-positives, they become frustated
		and their trust in the tool is reduced, making them
		less likely to use the tool again.
\end{itemize}

Similarly to the Rust compiler, the reports contain
detailed information about the issues, including
the line of code in which each one was found, both short and long description
of the triggered lint and, if possible, reference links to the Rust documentation
describing the semver issue in more detail.

\section{Plans to merge the tool into cargo}

There are already on-going plans to merge cargo-semver-checks into
the official Rust development toolchain,
which has been initiated by one of the developers working on cargo \cite{issue-merge-cargo}.
That would make the tool available to all Rust programmers
through a cargo subcommand and would be a huge step towards reducing the number of
package releases with semver issues.

Because of those plans, the commandline interface of the project is similar
to the interface of cargo's subcommands. Additionally, cargo developers
take part in discussions about the design of the interface \cite{issue-cli-interface}
or sometimes even review changes to the code or develop new functionalities.

It is cargo-semver-checks that was chosen to be merged into cargo,
not the other semver issues detecting tools,
mainly because it is the easiest to maintain
(as described in \ref{r:section_existing_semver_tools})
and doesn't report false-positives.

\section{Project usage}

The basic functionality of the tool is to compare two versions of the code
(the ,,current'' crate and the ,,baseline'' crate)
and notify the user about the semver issues that were found when checking the two versions.

One can run the tool by directly passing the path to the current crate
and either getting the baseline crate from registry, or by directly passing
a path to the baseline crate.

Because a large portion of libraries are currently developed using GitHub,
we are also providing a continuous integration job
via GitHub Actions to automatically ensure that
a Pull Request satisfies semver.

\subsection{Running locally}

The tool can be used on a local copy of the project
(for example, just before releasing its new version to the registry
through \texttt{cargo publish})
by passing the path to its manifest.
The baseline crate can be passed in a similar manner,
but alternatively it's possible to either
specify a version of the crate in the registry with which the
current crate should be compared with, or
(assuming that the current directory is a git repository)
by passing a git revision where the baseline project is located.

Additionally, it is possible to check all crates in a workspace
(which is a collection of crates)
one by one
by passing the path to the manifest that defines the workspace.

\subsection{Usage in continuous integration}

Seeing that GitHub is the most popular internet hosting service for version control
amongst the Rust libraries developers,
one of the goals of the project is to implement a GitHub Action
that checks whether a given git branch hasn't violated semver with recent changes.

There are two reasons as to why this continuous integration job is beneficial for the developers:
\begin{itemize}
	\item it can be used together with a job that automatically publishes a new version of the library
		when it passes the semver lints and the version of the package has been raised
		in the manifest file,
	\item it provides important information for library maintainers for deciding when
		a Pull Request should be merged -- in case the branch contains a minor or major change,
		the maintainers could want to wait with merging it until they plan to make
		a minor or major release of their library.
\end{itemize}

TODO:
\begin{itemize}
	\item ask Mieszko to check this section
\end{itemize}

\section{Project baseline}

Before our contributions, the project was already partially functional,
but it had numerous issues which often prevented the community from adopting the tool
into their workflow:
\begin{itemize}
	\item the project didn't have many lints,
	\item the code was bugged in multiple ways and lacked some functionality,
	\item the community wasn't satisfied with the implemented GitHub Action to the point where
		some developers coded their own continuous integration job using just the command-line interface of the tool,
	\item some existing lints had false-positives,
	\item the codebase was not in a state where new contributors could easily begin making changes
		to the project (which is crucial for the project to flourish in the long term).
		For example, adding new lints and tests wasn't intuitive and required many manual steps, 
		the filenames and variable names were not always descriptive enough
		and the code lacked comments that explained some of the logic and decisions behind it.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%               Theory                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Theory}\label{r:chapter_theory}

\section{Project structure}\label{r:section_projectstructure}

TODO:
\begin{itemize}
	\item explain that the tool heavily uses rustdocs
	\item explain that it parses rustdoc through Trustfall
	\item define Trustfall
	\item explain how the lints look like
	\item mention that the project is split into three sub-projects,
		in this order: cargo-semver-checks, trustfall-rustdoc-adapter, trustfall-rustdoc,
		cargo-semver-checks-action,
		and briefly define what they do (like in our docs)
\end{itemize}

\section{cargo-semver-checks}

TODO:
\begin{itemize}
	\item describe in detail what is the job of cargo-semver-checks, without the adapters
	\item describe its different usages and how they retrieve the necessary data
\end{itemize}

\section{trustfall-rustdoc-adapter}

TODO:
\begin{itemize}
	\item describe the purpose of the rustdoc adapter
	\item mention what a Trustfall must implmement and that the rustdoc adapter
	\item describe what the adapter does and how trustfall-rustdoc-adapter achieves that
\end{itemize}

\section{trustfall-adapter}

TODO:
\begin{itemize}
	\item describe the purpose of the adapter and what it does
\end{itemize}

\section{cargo-semver-checks-action}

TODO:
\begin{itemize}
	\item describe the purpose of this subproject and what it does
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%           Implementation            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Implementation}\label{r:chapter_implementation}

TODO:
\begin{itemize}
	\item change names to ,,why users care about this''
\end{itemize}

\section{New lints}

<Here write a list about the new lints we've written>

\section{Test suite}

<Here write a list about the improvements in the testing suite>

\section{Command line interface}

<Here write a list about changes that made the command line interface better>

\section{Bugfixes}

<Here write a list about found and fixed bugs>

\section{Continuous integration improvements}

<Here write a list about the V2 of the continuous integration>

\section{Script}

<Here write about the script that searches all existing releases for detected semver breaks>

\section{Healthier codebase}

<Here write a list of changes that made the codebase better>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             Evaluation              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation}\label{r:chapter_evaluation}

\section{Steady increase in tool's popularity}

TODO:
\begin{itemize}
	\item show how the number of downloads has changed
	\item show how the number of stars on GitHub has changed
	\item describe how our work might have impacted those results
	\item show the comments of users on GitHub.
		As one of the examples, give the maintainer of a big
		library that created an issue ,,Make continuous integration runs faster''
		and after learning about one of our PRs to make the continuous integration faster,
		he was so excited that he wrote a comment with a tip in our PR.
		Search also for other such examples in the PRs and issues.
	\item list the maintainers of big libraries that started using the tool during our development
\end{itemize}

\section{Script}

TODO:
\begin{itemize}
	\item show the results of the script that searches all existing releases for detected semver breaks
	\item describe how our new lints can make an impact on the community based on the found semver breaks from the script
\end{itemize}

\section{Future-proofing}

TODO:
\begin{itemize}
	\item describe other overall changes that prepares the tool to be more successful in the future
	\item describe how the code changed to be more welcoming for next contributors
\end{itemize}

\section{Conclusion}

TODO:
\begin{itemize}
	\item write a conclusion
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                Team                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Team}\label{r:chapter_team}

\section{Used methodology}

TODO:
\begin{itemize}
	\item describe how we've been developing the tool
	\item describe our mentor's reviews
	\item describe how initially we splitted our work and how we did it later
\end{itemize}

\section{Responsibilities}

TODO:
\begin{itemize}
	\item describe who did what
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%            Bibliography             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix

\begin{thebibliography}{99}\label{r:chapter_bibliography}
\addcontentsline{toc}{chapter}{Bibliography}

% \bibitem[Bea65]{beaman} Juliusz Beaman, \textit{Morbidity of the Jolly
%     function}, Mathematica Absurdica, 117 (1965) 338--9.
\bibitem{issue-merge-cargo} \href{}{GitHub cargo-semver-checks issue \#61: Prepare for merging into cargo}
\bibitem{issue-cli-interface} \href{}{GitHub cargo-semver-checks issue \#86 What should the CLI look like?}

\end{thebibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             Attachments             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter*{Attachments}\label{r:chapter_attachments}
\addcontentsline{toc}{chapter}{Attachments}

\section*{Source code structure}

<Here describe the project structure of the included CD>


\section*{Tests}

<Here describe the tests (and possibly how to run them) of the included CD>

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-2
%%% End:
