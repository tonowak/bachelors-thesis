\documentclass[licencjacka,en]{pracamgr}

\autor{Tomasz Nowak}{429575}
\autori{Michał Staniewski}{429598}
\autorii{Mieszko Grodzicki}{429132}
\autoriii{Bartosz Smolarczyk}{429594}
\opiekun{mgr Michał Możdżonek\\
  Institute of Informatics\\
  }
\date{May 2023}
\kierunek{Computer Science}
% Wg klasyfikacji Socrates-Erasmus:
\dziedzina{
11.3 Computer Science\\
}
% Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
\klasyfikacja{
  D. Software\\
  D.2. Software Engineering\\
  D.2.4. Software/Program Verification
  }

\title{Accelerating package expansion in Rust through development of a semantic versioning tool}
\titlepl{Przyspieszenie rozwoju pakietów w języku Rust poprzez rozbudowę narzędzia do semantycznego wersjonowania}
\keywords{Rust, semantic versioning, continuous integration, package manager}

\begin{document}
\maketitle

\begin{abstract}
In many programming languages there exist countless nuances,
making developers accidentally release new versions of their packages
that are not backwards-compatible.
Such releases can directly impact projects which are using their packages,
causing bugs or even compilation errors when using the latest version.
One of the affected languages is Rust,
which also lacks (itself) a built-in mechanism for enforcing semantic versioning.

The aim of this thesis is to describe the development of a tool
for Rust programmers to reduce the chances of publishing
a new version of the code that violates semantic versioning.

There are already on-going plans to bundle this tool
into the language's standard development toolchain.
It would make it commonly used and therefore help users to safely get bug fixes,
security patches and new functionality,
without worrying about their app being broken by a dependency change.
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftables

\chapter*{Executive summary}
\addcontentsline{toc}{chapter}{Executive summary}

TODO:
\begin{itemize}
	\item write the executive summary (around one page long)
	\item describe in short what is the goal of the project and what it solves
	\item describe that the project is indeed needed
	\item mention what we've done and how it moved the project towards the vision
	\item mention the results and the impact on the community
\end{itemize}

\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

Rust is a relatively new language that has lately been gaining on popularity.
Amongst its standard development toolchain there is a software called cargo
-- Rust's build system and package manager,
which handles building a crate -- a package with Rust code.
One of cargo's responsibilities is to search for the newest crate versions,
download them and build dependencies
(that is, other libraries / crates that the code uses).

Cargo assumes that all crates follow semantic versioning
-- a set of rules that decide when it is safe to use the new version of a library
without any problems (the projects that depend on this library must still compile).
Thanks to that, developers of libraries can release patches and bugfixes
and cargo by default will automatically use those newest releases.
The exact definition of semantic versioning is explained in chapter \ref{r:chapter_definitions}.

It turns out that it is not obvious which changes are backwards-compatible
and which are not. There are numerous examples (listed in \ref{r:section_usageofsemver})
where experienced Rust developers made a mistake
(due to insufficient knowledge about the language or by overlooking something)
that changed the public API of a library in such a way that users' code stopped compiling.

The authors of this thesis present their work on a tool that detects and notifies about
a subset of problems that make Rust libraries' public API non-backwards compatible,
with the goal to make problems with semantic versioning less frequent in the Rust community.
The exact goals of this project are described in chapter \ref{r:chapter_vision}.

The project is open-source -- all of the authors' work is visible in public repositories
(listed in \ref{r:section_projectstructure}). The project existed before their contributions,
thus chapter \ref{r:chapter_implementation} mainly describes how they have
extended the project's functionalities and fixed its issues.
Chapter \ref{r:chapter_evaluation} is a summary of their results and the project's impact
on the Rust community.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             Definitions             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Definitions}\label{r:chapter_definitions}

\section{Rust language}

With its first stable release in 2015, Rust is a relatively new programming language that
puts a strong emphasis on type-safety, memory-safety, performance and concurrency. Unlike
other memory-safe languages, Rust does not use reference counting nor garbage collector.
Instead it tracks the object lifetime of all the program's references during compilation,
using its built-in mechanism named "borrow checker".

Among many benefits and advantages of using Rust there are three dominant features. Firstly,
it provides the user with great performance, both time- and memory-wise, allowing for
writing efficient applications. Secondly, it is reliable -- with extensive type system and
focus on runtime safety, Rust prevents the user from making multiple bugs
already during compilation. Finally, it boosts productivity -- its documentation is
comprehensive and the compiler's error messages are clear and helpful. Rust also provides
an easy to use, integrated package manager (named cargo), a dedicated build tool,
an auto-formatter and many more.

According to surveys conducted among developers, Rust is considered to be the most enjoyable
programming language for the 7th year in a row (as of 2022 summary, meaning it was always on top
since its release in 2015). Over 87\% of respondents who have previously used Rust would
like to continue programming in it.

Because of the high level of safety it provides, Rust has also become the secondary
language for writing Linux kernel (with the primary being C). While there have been
attempts to add other languages (f.e. C++ in 1997), Rust is the first one to successfully
make it since the kernel's first release in 1991.

% TODO:
% \begin{itemize}
% 	\item describe Rust
% 	\item mention its main selling points, wikipedia might be helpful
% 		(though write the description yourself, without copy-pasting),
% 		alternatively search for more informal Rust descriptions
% 	\item mention its popularity (stackoverflow surveys, linux kernel, etc)
% \end{itemize}

\section{Rust's package manager and build system -- cargo}

Cargo is the official package manager for Rust. It is responsible for compiling the user's packages,
downloading their dependencies and uploading them to the selected package registry. It is important
to note that in Rust, packages are often refered to as crates with both names being equivalent
and commonly used.

One can think of cargo as the Rust analogue of Python's pip. But although their roles are
similar, cargo has many advantages making it a lot safer than pip:
\begin{itemize}
	\item Cargo's crates are installed using venvs (virtual environments), thus they cannot be
		installed in a location that would interfere with unrelated code.
	\item When user adds a crate to their project, they can only use its interface and there is
		no possibility of accessing eventual dependencies installed with it.
	\item The crate's name must also be included in a special file named \texttt{Cargo.toml}, not just in the source
		code file.
	\item To make the package's public interface explicit, Rust provides a series of tools for privacy
		management. Because of this it is much more difficult for the user to make their project dependent
		on something that the package's author did not intend to offer and could make private in future
		versions, causing a difficult to detect break on the user's end.
	\item Compatibility is taken seriously in Rust, thus packages' APIs are expected to be backwards-compatible
		(and to follow semantic versioning, described in another section) when a new version is released.
		If a package does not satisfy this requirement, there exists a procedure called \textit{yanking}.
		It allows to remove the faulty version from the index without deleting any data, but moves the
		index back to the most recent working version.
		Yet in case an incompatible package is downloaded before being yanked, projects using the package
		still mostly break during compilation or build time rather than runtime.
	\item The packages are also written in Rust and never require anything to work other than the package
		code itself. This minimizes the threat of missing pre-installed system dependencies.
	\item Cargo allows for an executable to contain different versions of the same package, enabling the user to
		include multiple dependencies based on a shared sub-dependency. If multiple versions of the
		sub-dependency are required, they are all included without conflicts.
\end{itemize}

Each package in Rust contains a special \texttt{Cargo.toml} file, called \textit{manifest}. It is
written in the TOML format for simplicity and contains all the metadata necessary for the package
to compile. Every manifest has numerous sections, with the most important two being:
\begin{itemize}
	\item \texttt{[package]} -- contains the information for cargo to compile the package.
		The minimum that must be provided are the package's name and version. Additional fields may be
		required if the maintainer wants to share their work with others by publishing to a registry.
	\item \texttt{[dependencies]} -- lists all of the package's dependencies.
		Before compiling, cargo has to serach for and download all of them. The default search location
		is crates.io. In this case, the minimum required for each dependency are its name and version.
\end{itemize}
Presence of the manifest file allows the crates.io registry to display useful information about a particular package.
The users are provided with a Readme file, instructions on how to add the package to their own Cargo.toml
file, a list of all available versions, statistics regarding the downloads for each version and more.

There also exists a second, special cargo file -- \texttt{Cargo.lock}. It contains detailed information about
the used dependencies. Since all dependencies come from some version control system, the user may not need to
provide an exact revision of a dependency in their \texttt{Cargo.toml} file. In this case, there are two scenarios
for what happens with the \texttt{Cargo.lock} file during compilation:
\begin{itemize}
	\item \texttt{Cargo.lock} is \textit{not} present -- cargo then creates it and for each dependency in
		the manifest downloads the most recent revision available, saving additional data about
		it in the file.
	\item \texttt{Cargo.lock} is present -- for the dependencies already present in the file cargo does not
		look for their newest version and instead downloads the one specified in the file. For dependencies that
		are not present it does the same as above except it adds them to the file rather than overwrites it.
\end{itemize}
There is a dedicated command for updating the dependencies -- \texttt{cargo update}. Upon execution,
the \texttt{Cargo.lock} file is either created or updated with the latest revisions of used dependencies.

Besides downloading dependencies, users can also publish their own packages using the \texttt{cargo publish} command.
To use the command, the user must first authenticate with an API token. After doing so, the command
first performs preliminary checks, including searching the manifest for a key to determine whether the user
is allowed to upload their package to the selected registry (by default crates.io). Once the checks are passed, all of the
source code from the current directory is compressed into a single \texttt{.crate} that is then uploaded to the registry.

% TODO:
% \begin{itemize}
% 	\item describe cargo
% 	\item compare it to Python's pip -- a lot of people know what it is
% 	\item mention differences with pip -- e.g. yanking releases
% 	\item mention that it follows semver and it is described in another section
% 	\item define Manifest file
% 	\item describe what happens during cargo update
% 	\item define the registry and mention its site -- crates.io
% 	\item describe how publishing packages work (e.g. how the CLI for it works)
% \end{itemize}

\section{Semantic versioning (semver)}

TODO:
\begin{itemize}
	\item define semantic versioning, semver.org might be useful
	\item describe why it is used
	\item exactly define how semver works in Rust
	\item mention how yanking releases is useful for semver
	\item mention that it is not clearly defined in Rust what is patch, minor and major,
		use the comments from Predrag's tweets about patch vs minor https://twitter.com/PredragGruevski/status/1618684048389607424
		and Predrag's blog about breaking vs major https://predr.ag/blog/some-rust-breaking-changes-do-not-require-major-version/
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%          State of the art           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{State of the art}\label{r:chapter_stateoftheart}

\section{Problems with using semver in Rust}\label{r:section_usageofsemver}

TODO:
\begin{itemize}
	\item explain why it is easy to break semver in Rust.
		Do that by giving specific, non-obvious code examples.
	\item search for sources from which to get examples
	\item explain other reasons as to why people tend to break semver
	\item don't give yet real-life examples (those will be in the sections under),
		write in a general way
	\item make it clear that using semver in Rust is hard
\end{itemize}

\section{Consequences of breaking semver}

TODO:
\begin{itemize}
	\item describe that breaking semver means that people's code stops compiling
	\item describe the possible scale of catastrophes
	\item don't give yet real-life examples, write in a general way
\end{itemize}

\section{Real-life examples of semver breaks}

TODO:
\begin{itemize}
	\item write (and cite) about cases our mentor mentioned in his blogs
	\item write about cases users reported in the github issue
	\item mention the paper describing that 43\% of yanked releases
		are because of semver breaks and 3.7\% of all >300'000 releases are yanked
	\item mention that we've developed
		a script that scans all releases for the semver breaks
		we can detect and the results are presented in some chapter
\end{itemize}

\section{Existing tools for detecting semver breaks}

TODO:
\begin{itemize}
	\item list languages which have semver checking built-in,
		explain that the language semantics were made for e.g. semver checking,
	\item list current tools for detecting semver breaks in Rust:
		cargo-breaking, rust-semverver, cargo-semver-checks
	\item for the first two, explain a bit how they work and why they are no longer maintained.
		Mieszko's slides have some info about that.
	\item for cargo-semver-checks, explain a bit how it works (rustdoc, json, etc.)
		and that contrary to the other two, it is maintained and it's made to be easily maintained.
		Mention that this is the project we're working on.
	\item research the current state of semver detection in other languages,
		explain that it's hard to do in popular languages,
		especially without features like rustdoc.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%               Vision                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Vision}\label{r:chapter_vision}

\section{Project purpose}

TODO:
\begin{itemize}
	\item explain for what the tool is designed for.
	\item explain its goals.
\end{itemize}

\section{Plans to merge the tool into cargo}

TODO:
\begin{itemize}
	\item mention why this project was chosen to be merged into cargo
	\item mention how that changed the project
	\item mention the progress with merging
	\item explain that it will happen with high probability
\end{itemize}

\section{Project usage}

TODO:
\begin{itemize}
	\item list two usages of the tool: running it locally and from CI
	\item explain them briefly
\end{itemize}

\subsection{Running locally}

TODO:
\begin{itemize}
	\item explain why someone would want to run it locally, mention \texttt{cargo publish}
	\item explain what options the user needs to run it locally (different ways to get rustdoc)
\end{itemize}

\subsection{Running in continuous integration}

TODO:
\begin{itemize}
	\item define PRs and GitHub
	\item describe the vision on how the tool should be automatically run in continuous integration
		and how that will benefit the Rust developers
\end{itemize}

\section{Project baseline}

TODO:
\begin{itemize}
	\item explain the state of the project before our contributions
	\item explain the issues of the project before our contributions
	\item explain how much the project vision weren't done before us
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%               Theory                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Theory}\label{r:chapter_theory}

\section{Project structure}\label{r:section_projectstructure}

TODO:
\begin{itemize}
	\item explain that the tool heavily uses rustdocs
	\item explain that it parses rustdoc through Trustfall
	\item define Trustfall
	\item explain how the lints look like
	\item mention that the project is split into three sub-projects,
		in this order: cargo-semver-checks, trustfall-rustdoc-adapter, trustfall-rustdoc,
		cargo-semver-checks-action,
		and briefly define what they do (like in our docs)
\end{itemize}

\section{cargo-semver-checks}

TODO:
\begin{itemize}
	\item describe in detail what is the job of cargo-semver-checks, without the adapters
	\item describe its different usages and how they retrieve the necessary data
\end{itemize}

\section{trustfall-rustdoc-adapter}

TODO:
\begin{itemize}
	\item describe the purpose of the rustdoc adapter
	\item mention what a Trustfall must implmement and that the rustdoc adapter
	\item describe what the adapter does and how trustfall-rustdoc-adapter achieves that
\end{itemize}

\section{trustfall-adapter}

TODO:
\begin{itemize}
	\item describe the purpose of the adapter and what it does
\end{itemize}

\section{cargo-semver-checks-action}

TODO:
\begin{itemize}
	\item describe the purpose of this subproject and what it does
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%           Implementation            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Implementation}\label{r:chapter_implementation}

TODO:
\begin{itemize}
	\item change names to ,,why users care about this''
\end{itemize}

\section{New lints}

<Here write a list about the new lints we've written>

\section{Test suite}

<Here write a list about the improvements in the testing suite>

\section{Command line interface}

<Here write a list about changes that made the command line interface better>

\section{Bugfixes}

<Here write a list about found and fixed bugs>

\section{Continuous integration improvements}

<Here write a list about the V2 of the continuous integration>

\section{Script}

<Here write about the script that searches all existing releases for detected semver breaks>

\section{Healthier codebase}

<Here write a list of changes that made the codebase better>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             Evaluation              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation}\label{r:chapter_evaluation}

\section{Steady increase in tool's popularity}

TODO:
\begin{itemize}
	\item show how the number of downloads has changed
	\item show how the number of stars on GitHub has changed
	\item describe how our work might have impacted those results
	\item show the comments of users on GitHub.
		As one of the examples, give the maintainer of a big
		library that created an issue ,,Make continuous integration runs faster''
		and after learning about one of our PRs to make the continuous integration faster,
		he was so excited that he wrote a comment with a tip in our PR.
		Search also for other such examples in the PRs and issues.
	\item list the maintainers of big libraries that started using the tool during our development
\end{itemize}

\section{Script}

TODO:
\begin{itemize}
	\item show the results of the script that searches all existing releases for detected semver breaks
	\item describe how our new lints can make an impact on the community based on the found semver breaks from the script
\end{itemize}

\section{Future-proofing}

TODO:
\begin{itemize}
	\item describe other overall changes that prepares the tool to be more successful in the future
	\item describe how the code changed to be more welcoming for next contributors
\end{itemize}

\section{Conclusion}

TODO:
\begin{itemize}
	\item write a conclusion
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                Team                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Team}\label{r:chapter_team}

\section{Used methodology}

TODO:
\begin{itemize}
	\item describe how we've been developing the tool
	\item describe our mentor's reviews
	\item describe how initially we splitted our work and how we did it later
\end{itemize}

\section{Responsibilities}

TODO:
\begin{itemize}
	\item describe who did what
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%            Bibliography             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix

\begin{thebibliography}{99}\label{r:chapter_bibliography}
\addcontentsline{toc}{chapter}{Bibliography}

% \bibitem[Bea65]{beaman} Juliusz Beaman, \textit{Morbidity of the Jolly
%     function}, Mathematica Absurdica, 117 (1965) 338--9.

\bibitem[]{Rust-1} Rust Team,
	\textit{Rust Programming Language} (2023) \\
	https://www.rust-lang.org/

\bibitem[]{Rust-2} Wikipedia,
	\textit{Rust (programming language)} (2023) \\
	https://en.wikipedia.org/wiki/Rust\_(programming\_language)/

\bibitem[]{survey} Stack Overflow,
	\textit{Annual Developer Survey} (2022) \\
	https://insights.stackoverflow.com/survey/

\bibitem[]{Rust-for-Linux} Wikipedia,
	\textit{Rust for Linux} (2023) \\
	https://en.wikipedia.org/wiki/Rust\_for\_Linux/

\bibitem[]{Cargo} Rust Team,
	\textit{The Cargo Book} (2023) \\
	https://doc.rust-lang.org/cargo/index.html/

\bibitem[]{Cargo-vs-pip} William Manley,
	\textit{Pip and Cargo are not the same} (2022) \\
	https://doc.rust-lang.org/cargo/index.html/

\end{thebibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             Attachments             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter*{Attachments}\label{r:chapter_attachments}
\addcontentsline{toc}{chapter}{Attachments}

\section*{Source code structure}

<Here describe the project structure of the included CD>


\section*{Tests}

<Here describe the tests (and possibly how to run them) of the included CD>

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-2
%%% End:
